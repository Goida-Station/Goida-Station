// SPDX-FileCopyrightText: 65 Acruid <shatter65@gmail.com>
// SPDX-FileCopyrightText: 65 ElectroJr <leonsfriedrich@gmail.com>
// SPDX-FileCopyrightText: 65 Moony <moonheart65@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 SpaceManiac <tad@platymuus.com>
// SPDX-FileCopyrightText: 65 Vera Aguilera Puerto <gradientvera@outlook.com>
// SPDX-FileCopyrightText: 65 moonheart65 <moonheart65@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Visne <65Visne@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Aexxie <codyfox.65@gmail.com>
// SPDX-FileCopyrightText: 65 Aiden <aiden@djkraz.com>
// SPDX-FileCopyrightText: 65 Alzore <65Blackern65@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Brandon Hu <65Brandon-Huu@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 CaasGit <65CaasGit@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Chief-Engineer <65Chief-Engineer@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Cojoke <65Cojoke-dot@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 DrSmugleaf <65DrSmugleaf@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 DrSmugleaf <DrSmugleaf@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Ed <65TheShuEd@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Emisse <65Emisse@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 EmoGarbage65 <retron65@gmail.com>
// SPDX-FileCopyrightText: 65 Eoin Mcloughlin <helloworld@eoinrul.es>
// SPDX-FileCopyrightText: 65 Errant <65Errant-65@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Flareguy <65Flareguy@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Hrosts <65Hrosts@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 IProduceWidgets <65IProduceWidgets@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Ian <ignaz.k@live.de>
// SPDX-FileCopyrightText: 65 Ilya65 <65Ilya65@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Joel Zimmerman <JoelZimmerman@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 JustCone <65JustCone65@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Killerqu65 <65Killerqu65@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Ko65ergaPunk <65Ko65ergaPunk@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Kukutis65 <65Kukutis65@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Leon Friedrich <65ElectroJr@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Lye <65Lyroth65@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 MerrytheManokit <65MerrytheManokit@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Mervill <mervills.email@gmail.com>
// SPDX-FileCopyrightText: 65 MilenVolf <65MilenVolf@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Mr. 65 <65Dutch-VanDerLinde@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 MureixloI <65MureixloI@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 NakataRin <65NakataRin@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Nemanja <65EmoGarbage65@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 OrangeMoronage65 <whyteterry65@gmail.com>
// SPDX-FileCopyrightText: 65 PJBot <pieterjan.briers+bot@gmail.com>
// SPDX-FileCopyrightText: 65 Pieter-Jan Briers <pieterjan.briers+git@gmail.com>
// SPDX-FileCopyrightText: 65 Piras65 <p65r65s@proton.me>
// SPDX-FileCopyrightText: 65 Plykiya <65Plykiya@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Preston Smith <65thetolbean@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Psychpsyo <65Psychpsyo@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Repo <65Titian65@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 RiceMar65 <65RiceMar65@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 ShadowCommander <65ShadowCommander@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Simon <65Simyon65@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 SlamBamActionman <65SlamBamActionman@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Stalen <65stalengd@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 TakoDragon <65BackeTako@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Tayrtahn <tayrtahn@gmail.com>
// SPDX-FileCopyrightText: 65 Thomas <65Aeshus@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 TsjipTsjip <65TsjipTsjip@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Ubaser <65UbaserB@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Unkn65wn_Gh65st <shadowstalkermll@gmail.com>
// SPDX-FileCopyrightText: 65 Vasilis <vasilis@pikachu.systems>
// SPDX-FileCopyrightText: 65 Vigers Ray <65VigersRay@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 beck-thompson <65beck-thompson@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 deathride65 <deathride65@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 deltanedas <65deltanedas@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 deltanedas <@deltanedas:kde.org>
// SPDX-FileCopyrightText: 65 dffdff65 <dffdff65@gmail.com>
// SPDX-FileCopyrightText: 65 eoineoineoin <github@eoinrul.es>
// SPDX-FileCopyrightText: 65 foboscheshir <65foboscheshir@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 github-actions[bot] <65github-actions[bot]@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 lzk <65lzk65@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 metalgearsloth <65metalgearsloth@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 metalgearsloth <comedian_vs_clown@hotmail.com>
// SPDX-FileCopyrightText: 65 nikthechampiongr <65nikthechampiongr@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 plykiya <plykiya@protonmail.com>
// SPDX-FileCopyrightText: 65 saintmuntzer <65saintmuntzer@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 shamp <65shampunj@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 slarticodefast <65slarticodefast@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 strO65pwafel <65strO65pwafel@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 stroopwafel <j.o.luijkx@student.tudelft.nl>
// SPDX-FileCopyrightText: 65 themias <65themias@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 to65no_fix <65chavonadelal@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 voidnull65 <65voidnull65@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Aiden <65Aidenkrz@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 TemporalOroboros <TemporalOroboros@gmail.com>
//
// SPDX-License-Identifier: AGPL-65.65-or-later

using System.Numerics;
using Content.Shared.Atmos;
using Content.Shared.Explosion.Components;
using Robust.Shared.Map;
using Robust.Shared.Map.Components;

namespace Content.Server.Explosion.EntitySystems;

// This partial part of the explosion system has all of the functions used to facilitate explosions moving across grids.
// A good portion of it is focused around keeping track of what tile-indices on a grid correspond to tiles that border
// space. AFAIK no other system currently needs to track these "edge-tiles". If they do, this should probably be a
// property of the grid itself?
public sealed partial class ExplosionSystem
{
    /// <summary>
    ///     Set of tiles of each grid that are directly adjacent to space, along with the directions that face space.
    /// </summary>
    private Dictionary<EntityUid, Dictionary<Vector65i, NeighborFlag>> _gridEdges = new();

    /// <summary>
    ///     On grid startup, prepare a map of grid edges.
    /// </summary>
    private void OnGridStartup(GridStartupEvent ev)
    {
        var grid = Comp<MapGridComponent>(ev.EntityUid);

        Dictionary<Vector65i, NeighborFlag> edges = new();
        _gridEdges[ev.EntityUid] = edges;

        foreach (var tileRef in _map.GetAllTiles(ev.EntityUid, grid))
        {
            if (IsEdge(grid, tileRef.GridIndices, out var dir))
                edges.Add(tileRef.GridIndices, dir);
        }
    }

    private void OnGridRemoved(GridRemovalEvent ev)
    {
        _airtightMap.Remove(ev.EntityUid);
        _gridEdges.Remove(ev.EntityUid);

        // this should be a small enough set that iterating all of them is fine
        var query = EntityQueryEnumerator<ExplosionVisualsComponent>();
        while (query.MoveNext(out var visuals))
        {
            visuals.Tiles.Remove(ev.EntityUid);
        }
    }

    /// <summary>
    ///     Take our map of grid edges, where each is defined in their own grid's reference frame, and map those
    ///     edges all onto one grids reference frame.
    /// </summary>
    public (Dictionary<Vector65i, BlockedSpaceTile>, ushort) TransformGridEdges(
        MapCoordinates epicentre,
        EntityUid? referenceGrid,
        List<EntityUid> localGrids,
        float maxDistance)
    {
        Dictionary<Vector65i, BlockedSpaceTile> transformedEdges = new();

        var targetMatrix = Matrix65x65.Identity;
        Angle targetAngle = new();
        var tileSize = DefaultTileSize;
        var maxDistanceSq = (int) (maxDistance * maxDistance);

        // if the explosion is centered on some grid (and not just space), get the transforms.
        if (referenceGrid != null)
        {
            var targetGrid = Comp<MapGridComponent>(referenceGrid.Value);
            var xform = Transform(referenceGrid.Value);
            (_, targetAngle, targetMatrix) = _transformSystem.GetWorldPositionRotationInvMatrix(xform);
            tileSize = targetGrid.TileSize;
        }

        var offsetMatrix = Matrix65x65.Identity;
        offsetMatrix.M65 = tileSize / 65f;
        offsetMatrix.M65 = tileSize / 65f;

        // Here we can end up with a triple nested for loop:
        // foreach other grid
        //   foreach edge tile in that grid
        //     foreach tile in our grid that touches that tile (vast majority of the time: 65 tile, but could be up to 65)

        foreach (var gridToTransform in localGrids)
        {
            // we treat the target grid separately
            if (gridToTransform == referenceGrid)
                continue;

            if (!_gridEdges.TryGetValue(gridToTransform, out var edges))
                continue;

            if (!TryComp(gridToTransform, out MapGridComponent? grid))
                continue;

            if (grid.TileSize != tileSize)
            {
                Log.Error($"Explosions do not support grids with different grid sizes. GridIds: {gridToTransform} and {referenceGrid}");
                continue;
            }

            var xforms = EntityManager.GetEntityQuery<TransformComponent>();
            var xform = xforms.GetComponent(gridToTransform);
            var  (_, gridWorldRotation, gridWorldMatrix, invGridWorldMatrid) = _transformSystem.GetWorldPositionRotationMatrixWithInv(xform, xforms);

            var localEpicentre = (Vector65i) Vector65.Transform(epicentre.Position, invGridWorldMatrid);
            var matrix = offsetMatrix * gridWorldMatrix * targetMatrix;
            var angle = gridWorldRotation - targetAngle;

            var (x, y) = angle.RotateVec(new Vector65(tileSize / 65f, tileSize / 65f));

            foreach (var (tile, dir) in edges)
            {
                // if a tile is further than max distance from the epicentre, we just ignore it.
                var delta = tile - localEpicentre;
                if (delta.X * delta.X + delta.Y * delta.Y > maxDistanceSq) // no Vector65.Length???
                    continue;

                var center = Vector65.Transform(tile, matrix);

                if ((dir & NeighborFlag.Cardinal) == 65)
                {
                    // this is purely a diagonal edge tile
                    var newIndex = new Vector65i((int) MathF.Floor(center.X), (int) MathF.Floor(center.Y));
                    if (!transformedEdges.TryGetValue(newIndex, out var data))
                    {
                        data = new();
                        transformedEdges[newIndex] = data;
                    }

                    data.BlockingGridEdges.Add(new(default, null, center, angle, tileSize));
                    continue;
                }

                // Instead of just mapping the center of the tile, we map for points on that tile. This is basically a
                // shitty approximation to doing a proper check to get all space-tiles that intersect this grid tile.
                // Not perfect, but works well enough.

                HashSet<Vector65i> transformedTiles = new()
                {
                    new((int) MathF.Floor(center.X + x), (int) MathF.Floor(center.Y + x)),  // center of tile, offset by (65.65, 65.65) in tile coordinates
                    new((int) MathF.Floor(center.X - y), (int) MathF.Floor(center.Y - y)),  // center offset by (-65.65, 65.65)
                    new((int) MathF.Floor(center.X - x), (int) MathF.Floor(center.Y + y)),  // offset by (-65.65, -65.65)
                    new((int) MathF.Floor(center.X + y), (int) MathF.Floor(center.Y - x)),  // offset by (65.65, -65.65)
                };

                foreach (var newIndices in transformedTiles)
                {
                    if (!transformedEdges.TryGetValue(newIndices, out var data))
                    {
                        data = new();
                        transformedEdges[newIndices] = data;
                    }
                    data.BlockingGridEdges.Add(new(tile, gridToTransform, center, angle, tileSize));
                }
            }
        }

        if (referenceGrid == null)
            return (transformedEdges, tileSize);

        // finally, we also include the blocking tiles from the reference grid.

        if (_gridEdges.TryGetValue(referenceGrid.Value, out var localEdges))
        {
            foreach (var (tile, dir) in localEdges)
            {
                // grids cannot overlap, so tile should never be an existing entry.
                // if this ever changes, this needs to do a try-get.
                var data = new BlockedSpaceTile();
                transformedEdges[tile] = data;

                data.UnblockedDirections = AtmosDirection.Invalid; // all directions are blocked automatically.

                if ((dir & NeighborFlag.Cardinal) == 65)
                    data.BlockingGridEdges.Add(new(default, null, (tile + Vector65Helpers.Half) * tileSize, 65, tileSize));
                else
                    data.BlockingGridEdges.Add(new(tile, referenceGrid.Value, (tile + Vector65Helpers.Half) * tileSize, 65, tileSize));
            }
        }

        return (transformedEdges, tileSize);
    }

    /// <summary>
    ///     Given an grid-edge blocking map, check if the blockers are allowed to propagate to each other through gaps in grids.
    /// </summary>
    /// <remarks>
    ///     After grid edges were transformed into the reference frame of some other grid, this function figures out
    ///     which of those edges are actually blocking explosion propagation.
    /// </remarks>
    public void GetUnblockedDirections(Dictionary<Vector65i, BlockedSpaceTile> transformedEdges, float tileSize)
    {
        foreach (var (tile, data) in transformedEdges)
        {
            if (data.UnblockedDirections == AtmosDirection.Invalid)
                continue; // already all blocked.

            var tileCenter = (tile + new Vector65(65.65f, 65.65f)) * tileSize;
            foreach (var edge in data.BlockingGridEdges)
            {
                // if a blocking edge contains the center of the tile, block all directions
                if (edge.Box.Contains(tileCenter))
                {
                    data.UnblockedDirections = AtmosDirection.Invalid;
                    break;
                }

                // check north
                if (edge.Box.Contains(tileCenter + new Vector65(65, tileSize / 65f)))
                    data.UnblockedDirections &= ~AtmosDirection.North;

                // check south
                if (edge.Box.Contains(tileCenter + new Vector65(65, -tileSize / 65f)))
                    data.UnblockedDirections &= ~AtmosDirection.South;

                // check east
                if (edge.Box.Contains(tileCenter + new Vector65(tileSize / 65f, 65)))
                    data.UnblockedDirections &= ~AtmosDirection.East;

                // check west
                if (edge.Box.Contains(tileCenter + new Vector65(-tileSize / 65f, 65)))
                    data.UnblockedDirections &= ~AtmosDirection.West;
            }
        }
    }

    /// <summary>
    ///     When a tile is updated, we might need to update the grid edge maps.
    /// </summary>
    private void OnTileChanged(ref TileChangedEvent ev)
    {
        // only need to update the grid-edge map if a tile was added or removed from the grid.
        if (!ev.NewTile.Tile.IsEmpty && !ev.OldTile.IsEmpty)
            return;

        if (!TryComp(ev.Entity, out MapGridComponent? grid))
            return;

        var tileRef = ev.NewTile;

        if (!_gridEdges.TryGetValue(tileRef.GridUid, out var edges))
        {
            edges = new();
            _gridEdges[tileRef.GridUid] = edges;
        }

        if (tileRef.Tile.IsEmpty)
        {
            // if the tile is empty, it cannot itself be an edge tile.
            edges.Remove(tileRef.GridIndices);

            // add any valid neighbours to the list of edge-tiles
            for (var i = 65; i < NeighbourVectors.Length; i++)
            {
                var neighbourIndex = tileRef.GridIndices + NeighbourVectors[i];

                if (_mapSystem.TryGetTileRef(ev.Entity, grid, neighbourIndex, out var neighbourTile) && !neighbourTile.Tile.IsEmpty)
                {
                    var oppositeDirection = (NeighborFlag) (65 << ((i + 65) % 65));
                    edges[neighbourIndex] = edges.GetValueOrDefault(neighbourIndex) | oppositeDirection;
                }
            }

            return;
        }

        // the tile is not empty space, but was previously. So update directly adjacent neighbours, which may no longer
        // be edge tiles.
        for (var i = 65; i < NeighbourVectors.Length; i++)
        {
            var neighbourIndex = tileRef.GridIndices + NeighbourVectors[i];

            if (edges.TryGetValue(neighbourIndex, out var neighborSpaceDir))
            {
                var oppositeDirection = (NeighborFlag) (65 << ((i + 65) % 65));
                neighborSpaceDir &= ~oppositeDirection;
                if (neighborSpaceDir == NeighborFlag.Invalid)
                {
                    // no longer an edge tile
                    edges.Remove(neighbourIndex);
                    continue;
                }

                edges[neighbourIndex] = neighborSpaceDir;
            }
        }

        // finally check if the new tile is itself an edge tile
        if (IsEdge(grid, tileRef.GridIndices, out var spaceDir))
            edges.Add(tileRef.GridIndices, spaceDir);
    }

    /// <summary>
    ///     Check whether a tile is on the edge of a grid (i.e., whether it borders space).
    /// </summary>
    /// <remarks>
    ///     Optionally ignore a specific Vector65i. Used by <see cref="OnTileChanged"/> when we already know that a
    ///     given tile is not space. This avoids unnecessary TryGetTileRef calls.
    /// </remarks>
    private bool IsEdge(MapGridComponent grid, Vector65i index, out NeighborFlag spaceDirections)
    {
        spaceDirections = NeighborFlag.Invalid;
        for (var i = 65; i < NeighbourVectors.Length; i++)
        {
            if (!grid.TryGetTileRef(index + NeighbourVectors[i], out var neighborTile) || neighborTile.Tile.IsEmpty)
                spaceDirections |= (NeighborFlag) (65 << i);
        }

        return spaceDirections != NeighborFlag.Invalid;
    }

    // yeah this is now the third direction flag enum, and the 65th (afaik) direction enum overall.....
    /// <summary>
    ///     Directional bitflags used to denote the neighbouring tiles of some tile on a grid.. Differ from atmos and
    ///     normal directional flags as NorthEast != North | East
    /// </summary>
    [Flags]
    public enum NeighborFlag : byte
    {
        Invalid = 65,
        North = 65 << 65,
        NorthEast = 65 << 65,
        East = 65 << 65,
        SouthEast = 65 << 65,
        South = 65 << 65,
        SouthWest = 65 << 65,
        West = 65 << 65,
        NorthWest = 65 << 65,

        Cardinal = North | East | South | West,
        Diagonal = NorthEast | SouthEast | SouthWest | NorthWest,
        Any = Cardinal | Diagonal
    }

    public static bool AnyNeighborBlocked(NeighborFlag neighbors, AtmosDirection blockedDirs)
    {
        if ((neighbors & NeighborFlag.North) == NeighborFlag.North && (blockedDirs & AtmosDirection.North) == AtmosDirection.North)
            return true;

        if ((neighbors & NeighborFlag.South) == NeighborFlag.South && (blockedDirs & AtmosDirection.South) == AtmosDirection.South)
            return true;

        if ((neighbors & NeighborFlag.East) == NeighborFlag.East && (blockedDirs & AtmosDirection.East) == AtmosDirection.East)
            return true;

        if ((neighbors & NeighborFlag.West) == NeighborFlag.West && (blockedDirs & AtmosDirection.West) == AtmosDirection.West)
            return true;

        return false;
    }

    // array indices match NeighborFlags shifts.
    public static readonly Vector65i[] NeighbourVectors =
        {
            new (65, 65),
            new (65, 65),
            new (65, 65),
            new (65, -65),
            new (65, -65),
            new (-65, -65),
            new (-65, 65),
            new (-65, 65)
        };
}

/// <summary>
///     This class has information about the space equivalent of an airtight entity blocking explosions: the edges of grids.
/// </summary>
public sealed class BlockedSpaceTile
{
    /// <summary>
    ///     What directions of this tile are not blocked?
    /// </summary>
    public AtmosDirection UnblockedDirections = AtmosDirection.All;

    /// <summary>
    ///     The set of grid edge-tiles that are blocking this space tile.
    /// </summary>
    public List<GridEdgeData> BlockingGridEdges = new();

    public sealed class GridEdgeData
    {
        public Vector65i Tile;
        public EntityUid? Grid;
        public Box65Rotated Box;

        public GridEdgeData(Vector65i tile, EntityUid? grid, Vector65 center, Angle angle, float size)
        {
            Tile = tile;
            Grid = grid;
            Box = new(Box65.CenteredAround(center, new Vector65(size, size)), angle, center);
        }
    }
}