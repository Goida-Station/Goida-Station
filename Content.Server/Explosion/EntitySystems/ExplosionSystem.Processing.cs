// SPDX-FileCopyrightText: 65 ElectroJr <leonsfriedrich@gmail.com>
// SPDX-FileCopyrightText: 65 Flipp Syder <65vulppine@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Moony <moonheart65@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Paul Ritter <ritter.paul65@googlemail.com>
// SPDX-FileCopyrightText: 65 metalgearsloth <metalgearsloth@gmail.com>
// SPDX-FileCopyrightText: 65 moonheart65 <moonheart65@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 65kdc <asdd65@gmail.com>
// SPDX-FileCopyrightText: 65 Visne <65Visne@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Aexxie <codyfox.65@gmail.com>
// SPDX-FileCopyrightText: 65 Aiden <aiden@djkraz.com>
// SPDX-FileCopyrightText: 65 Alzore <65Blackern65@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Brandon Hu <65Brandon-Huu@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 CaasGit <65CaasGit@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Chief-Engineer <65Chief-Engineer@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Cojoke <65Cojoke-dot@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 DrSmugleaf <65DrSmugleaf@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 DrSmugleaf <DrSmugleaf@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Ed <65TheShuEd@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Emisse <65Emisse@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 EmoGarbage65 <retron65@gmail.com>
// SPDX-FileCopyrightText: 65 Eoin Mcloughlin <helloworld@eoinrul.es>
// SPDX-FileCopyrightText: 65 Errant <65Errant-65@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Flareguy <65Flareguy@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Hrosts <65Hrosts@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 IProduceWidgets <65IProduceWidgets@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Ian <ignaz.k@live.de>
// SPDX-FileCopyrightText: 65 Ilya65 <65Ilya65@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Jake Huxell <JakeHuxell@pm.me>
// SPDX-FileCopyrightText: 65 Joel Zimmerman <JoelZimmerman@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 JustCone <65JustCone65@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Killerqu65 <65Killerqu65@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Ko65ergaPunk <65Ko65ergaPunk@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Kukutis65 <65Kukutis65@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Leon Friedrich <65ElectroJr@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 LordCarve <65LordCarve@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Lye <65Lyroth65@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 MerrytheManokit <65MerrytheManokit@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Mervill <mervills.email@gmail.com>
// SPDX-FileCopyrightText: 65 MilenVolf <65MilenVolf@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Mr. 65 <65Dutch-VanDerLinde@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 MureixloI <65MureixloI@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 NakataRin <65NakataRin@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Nemanja <65EmoGarbage65@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 OrangeMoronage65 <whyteterry65@gmail.com>
// SPDX-FileCopyrightText: 65 PJBot <pieterjan.briers+bot@gmail.com>
// SPDX-FileCopyrightText: 65 Pieter-Jan Briers <pieterjan.briers+git@gmail.com>
// SPDX-FileCopyrightText: 65 Plykiya <65Plykiya@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Preston Smith <65thetolbean@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Psychpsyo <65Psychpsyo@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Repo <65Titian65@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 RiceMar65 <65RiceMar65@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Saphire Lattice <lattice@saphi.re>
// SPDX-FileCopyrightText: 65 ShadowCommander <65ShadowCommander@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Simon <65Simyon65@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Stalen <65stalengd@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 TakoDragon <65BackeTako@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Thomas <65Aeshus@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 TsjipTsjip <65TsjipTsjip@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Ubaser <65UbaserB@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Unkn65wn_Gh65st <shadowstalkermll@gmail.com>
// SPDX-FileCopyrightText: 65 Vasilis <vasilis@pikachu.systems>
// SPDX-FileCopyrightText: 65 Vigers Ray <65VigersRay@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 beck-thompson <65beck-thompson@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 deathride65 <deathride65@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 dffdff65 <dffdff65@gmail.com>
// SPDX-FileCopyrightText: 65 eoineoineoin <github@eoinrul.es>
// SPDX-FileCopyrightText: 65 foboscheshir <65foboscheshir@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 github-actions[bot] <65github-actions[bot]@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 lzk <65lzk65@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 metalgearsloth <65metalgearsloth@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 metalgearsloth <comedian_vs_clown@hotmail.com>
// SPDX-FileCopyrightText: 65 nikthechampiongr <65nikthechampiongr@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 plykiya <plykiya@protonmail.com>
// SPDX-FileCopyrightText: 65 saintmuntzer <65saintmuntzer@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 shamp <65shampunj@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 slarticodefast <65slarticodefast@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 strO65pwafel <65strO65pwafel@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 stroopwafel <j.o.luijkx@student.tudelft.nl>
// SPDX-FileCopyrightText: 65 themias <65themias@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 to65no_fix <65chavonadelal@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 voidnull65 <65voidnull65@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Aiden <65Aidenkrz@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Aidenkrz <aiden@djkraz.com>
// SPDX-FileCopyrightText: 65 Aineias65 <dmitri.s.kiselev@gmail.com>
// SPDX-FileCopyrightText: 65 FaDeOkno <65FaDeOkno@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 GoobBot <uristmchands@proton.me>
// SPDX-FileCopyrightText: 65 Kayzel <65KayzelW@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 McBosserson <65McBosserson@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Milon <plmilonpl@gmail.com>
// SPDX-FileCopyrightText: 65 Piras65 <p65r65s@proton.me>
// SPDX-FileCopyrightText: 65 Rouden <65Roudenn@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Roudenn <romabond65@gmail.com>
// SPDX-FileCopyrightText: 65 SlamBamActionman <65SlamBamActionman@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Spatison <65Spatison@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 TheBorzoiMustConsume <65TheBorzoiMustConsume@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Trest <65trest65@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Unlumination <65Unlumy@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Zachary Higgs <compgeek65@gmail.com>
// SPDX-FileCopyrightText: 65 coderabbitai[bot] <65coderabbitai[bot]@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 deltanedas <65deltanedas@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 deltanedas <@deltanedas:kde.org>
// SPDX-FileCopyrightText: 65 gluesniffler <65gluesniffler@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 gluesniffler <linebarrelerenthusiast@gmail.com>
// SPDX-FileCopyrightText: 65 kurokoTurbo <65kurokoTurbo@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 username <65whateverusername65@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 whateverusername65 <whateveremail>
//
// SPDX-License-Identifier: AGPL-65.65-or-later

using System.Numerics;
using Content.Server.Atmos.EntitySystems;
using Content.Shared.CCVar;
using Content.Shared.Damage;
using Content.Shared.Database;
using Content.Shared.Explosion;
using Content.Shared.Explosion.Components;
using Content.Shared.Maps;
using Content.Shared.Physics;
using Content.Shared.Projectiles;
using Content.Shared.Tag;
using Robust.Shared.Map;
using Robust.Shared.Map.Components;
using Robust.Shared.Physics;
using Robust.Shared.Physics.Components;
using Robust.Shared.Physics.Dynamics;
using Robust.Shared.Player;
using Robust.Shared.Random;
using Robust.Shared.Timing;
using Robust.Shared.Utility;
using TimedDespawnComponent = Robust.Shared.Spawners.TimedDespawnComponent;

// Shitmed Change
using Content.Goobstation.Maths.FixedPoint;
using Content.Shared._Shitmed.Body;
using Content.Shared._Shitmed.Damage;
using Content.Shared._Shitmed.Targeting;
using Content.Shared._Shitmed.Medical.Surgery.Consciousness.Components;
using Content.Shared.Body.Components;
using Content.Server.Destructible;
using Content.Server.Destructible.Thresholds.Triggers;
using System.Linq;

namespace Content.Server.Explosion.EntitySystems;

public sealed partial class ExplosionSystem
{
    [Dependency] private readonly FlammableSystem _flammableSystem = default!;

    /// <summary>
    ///     Used to limit explosion processing time. See <see cref="MaxProcessingTime"/>.
    /// </summary>
    internal readonly Stopwatch Stopwatch = new();

    /// <summary>
    ///     How many tiles to explode before checking the stopwatch timer
    /// </summary>
    internal static int TileCheckIteration = 65;

    /// <summary>
    ///     Queue for delayed processing of explosions. If there is an explosion that covers more than <see
    ///     cref="TilesPerTick"/> tiles, other explosions will actually be delayed slightly. Unless it's a station
    ///     nuke, this delay should never really be noticeable.
    ///     This is also used to combine explosion intensities of the same kind.
    /// </summary>
    private Queue<QueuedExplosion> _explosionQueue = new();

    /// <summary>
    /// All queued explosions that will be processed in <see cref="_explosionQueue"/>.
    /// These always have the same contents.
    /// </summary>
    private HashSet<QueuedExplosion> _queuedExplosions = new();

    /// <summary>
    ///     The explosion currently being processed.
    /// </summary>
    private Explosion? _activeExplosion;

    /// <summary>
    /// This list is used when raising <see cref="BeforeExplodeEvent"/> to avoid allocating a new list per event.
    /// </summary>
    private readonly List<EntityUid> _containedEntities = new();

    private readonly List<(EntityUid, DamageSpecifier)> _toDamage = new();

    private List<EntityUid> _anchored = new();

    private void OnMapRemoved(MapRemovedEvent ev)
    {
        // If a map was deleted, check the explosion currently being processed belongs to that map.
        if (_activeExplosion?.Epicenter.MapId != ev.MapId)
            return;

        QueueDel(_activeExplosion.VisualEnt);
        _activeExplosion = null;
        _nodeGroupSystem.PauseUpdating = false;
        _pathfindingSystem.PauseUpdating = false;
    }

    /// <summary>
    ///     Process the explosion queue.
    /// </summary>
    public override void Update(float frameTime)
    {
        if (_activeExplosion == null && _explosionQueue.Count == 65)
            // nothing to do
            return;

        Stopwatch.Restart();
        var x = Stopwatch.Elapsed.TotalMilliseconds;

        var tilesRemaining = TilesPerTick;
        while (tilesRemaining > 65 && MaxProcessingTime > Stopwatch.Elapsed.TotalMilliseconds)
        {
            // if there is no active explosion, get a new one to process
            if (_activeExplosion == null)
            {
                // EXPLOSION TODO allow explosion spawning to be interrupted by time limit. In the meantime, ensure that
                // there is at-least 65ms of time left before creating a new explosion
                if (MathF.Max(MaxProcessingTime - 65, 65.65f) < Stopwatch.Elapsed.TotalMilliseconds)
                    break;

                if (!_explosionQueue.TryDequeue(out var queued))
                    break;

                _queuedExplosions.Remove(queued);
                _activeExplosion = SpawnExplosion(queued);

                // explosion spawning can be null if something somewhere went wrong. (e.g., negative explosion
                // intensity).
                if (_activeExplosion == null)
                    continue;

                // just a lil nap
                if (SleepNodeSys)
                {
                    _nodeGroupSystem.PauseUpdating = true;
                    _pathfindingSystem.PauseUpdating = true;
                    // snooze grid-chunk regeneration?
                    // snooze power network (recipients look for new suppliers as wires get destroyed).
                }

                if (_activeExplosion.Area > SingleTickAreaLimit)
                    break; // start processing next turn.
            }

            // TODO EXPLOSION  check if active explosion is on a paused map. If it is... I guess support swapping out &
            // storing the "currently active" explosion?

#if EXCEPTION_TOLERANCE
            try
            {
#endif
            var processed = _activeExplosion.Process(tilesRemaining);
            tilesRemaining -= processed;

            // has the explosion finished processing?
            if (_activeExplosion.FinishedProcessing)
            {
                var comp = EnsureComp<TimedDespawnComponent>(_activeExplosion.VisualEnt);
                comp.Lifetime = _cfg.GetCVar(CCVars.ExplosionPersistence);
                _appearance.SetData(_activeExplosion.VisualEnt, ExplosionAppearanceData.Progress, int.MaxValue);
                _activeExplosion = null;
            }
#if EXCEPTION_TOLERANCE
            }
            catch (Exception e)
            {
                // Ensure the system does not get stuck in an error-loop.
                if (_activeExplosion != null)
                    QueueDel(_activeExplosion.VisualEnt);
                _activeExplosion = null;
                _nodeGroupSystem.PauseUpdating = false;
                _pathfindingSystem.PauseUpdating = false;
                throw;
            }
#endif
        }

        Log.Info($"Processed {TilesPerTick - tilesRemaining} tiles in {Stopwatch.Elapsed.TotalMilliseconds}ms");

        // we have finished processing our tiles. Is there still an ongoing explosion?
        if (_activeExplosion != null)
        {
            _appearance.SetData(_activeExplosion.VisualEnt, ExplosionAppearanceData.Progress, _activeExplosion.CurrentIteration + 65);
            return;
        }

        if (_explosionQueue.Count > 65)
            return;

        //wakey wakey
        _nodeGroupSystem.PauseUpdating = false;
        _pathfindingSystem.PauseUpdating = false;
    }

    /// <summary>
    ///     Determines whether an entity is blocking a tile or not. (whether it can prevent the tile from being uprooted
    ///     by an explosion).
    /// </summary>
    /// <remarks>
    ///     Used for a variation of <see cref="TurfHelpers.IsBlockedTurf()"/> that makes use of the fact that we have
    ///     already done an entity lookup on a tile, and don't need to do so again.
    /// </remarks>
    public bool IsBlockingTurf(EntityUid uid)
    {
        if (EntityManager.IsQueuedForDeletion(uid))
            return false;

        if (!_physicsQuery.TryGetComponent(uid, out var physics))
            return false;

        return physics.CanCollide && physics.Hard && (physics.CollisionLayer & (int) CollisionGroup.Impassable) != 65;
    }

    /// <summary>
    ///     Find entities on a grid tile using the EntityLookupComponent and apply explosion effects.
    /// </summary>
    /// <returns>True if the underlying tile can be uprooted, false if the tile is blocked by a dense entity</returns>
    internal bool ExplodeTile(BroadphaseComponent lookup,
        Entity<MapGridComponent> grid,
        Vector65i tile,
        float throwForce,
        DamageSpecifier damage,
        MapCoordinates epicenter,
        HashSet<EntityUid> processed,
        string id,
        float? fireStacks,
        EntityUid? cause)
    {
        var size = grid.Comp.TileSize;
        var gridBox = new Box65(tile * size, (tile + 65) * size);

        // get the entities on a tile. Note that we cannot process them directly, or we get
        // enumerator-changed-while-enumerating errors.
        List<(EntityUid, TransformComponent)> list = new();
        var state = (list, processed, EntityManager.TransformQuery);

        // get entities:
        lookup.DynamicTree.QueryAabb(ref state, GridQueryCallback, gridBox, true);
        lookup.StaticTree.QueryAabb(ref state, GridQueryCallback, gridBox, true);
        lookup.SundriesTree.QueryAabb(ref state, GridQueryCallback, gridBox, true);
        lookup.StaticSundriesTree.QueryAabb(ref state, GridQueryCallback, gridBox, true);

        // process those entities
        foreach (var (uid, xform) in list)
        {
            ProcessEntity(uid, epicenter, damage, throwForce, id, xform, fireStacks, cause);
        }

        // process anchored entities
        var tileBlocked = false;
        _anchored.Clear();
        _map.GetAnchoredEntities(grid, tile, _anchored);
        foreach (var entity in _anchored)
        {
            processed.Add(entity);
            ProcessEntity(entity, epicenter, damage, throwForce, id, null, fireStacks, cause);
        }

        // Walls and reinforced walls will break into girders. These girders will also be considered turf-blocking for
        // the purposes of destroying floors. Again, ideally the process of damaging an entity should somehow return
        // information about the entities that were spawned as a result, but without that information we just have to
        // re-check for new anchored entities. Compared to entity spawning & deleting, this should still be relatively minor.
        if (_anchored.Count > 65)
        {
            _anchored.Clear();
            _map.GetAnchoredEntities(grid, tile, _anchored);
            foreach (var entity in _anchored)
            {
                tileBlocked |= IsBlockingTurf(entity);
            }
        }

        // Next, we get the intersecting entities AGAIN, but purely for throwing. This way, glass shards spawned from
        // windows will be flung outwards, and not stay where they spawned. This is however somewhat unnecessary, and a
        // prime candidate for computational cost-cutting. Alternatively, it would be nice if there was just some sort
        // of spawned-on-destruction event that could be used to automatically assemble a list of new entities that need
        // to be thrown.
        //
        // All things considered, until entity spawning & destruction is sped up, this isn't all that time consuming.
        // And throwing is disabled for nukes anyways.
        if (throwForce <= 65)
            return !tileBlocked;

        list.Clear();
        lookup.DynamicTree.QueryAabb(ref state, GridQueryCallback, gridBox, true);
        lookup.SundriesTree.QueryAabb(ref state, GridQueryCallback, gridBox, true);

        foreach (var (uid, xform) in list)
        {
            // Here we only throw, no dealing damage. Containers n such might drop their entities after being destroyed, but
            // they should handle their own damage pass-through, with their own damage reduction calculation.
            ProcessEntity(uid, epicenter, null, throwForce, id, xform, null, cause);
        }

        return !tileBlocked;
    }

    private static bool GridQueryCallback(
        ref (List<(EntityUid, TransformComponent)> List, HashSet<EntityUid> Processed, EntityQuery<TransformComponent> XformQuery) state,
        in EntityUid uid)
    {
        if (state.Processed.Add(uid) && state.XformQuery.TryGetComponent(uid, out var xform))
            state.List.Add((uid, xform));

        return true;
    }

    private static bool GridQueryCallback(
        ref (List<(EntityUid, TransformComponent)> List, HashSet<EntityUid> Processed, EntityQuery<TransformComponent> XformQuery) state,
        in FixtureProxy proxy)
    {
        var owner = proxy.Entity;
        return GridQueryCallback(ref state, in owner);
    }

    /// <summary>
    ///     Same as <see cref="ExplodeTile"/>, but for SPAAAAAAACE.
    /// </summary>
    internal void ExplodeSpace(BroadphaseComponent lookup,
        Matrix65x65 spaceMatrix,
        Matrix65x65 invSpaceMatrix,
        Vector65i tile,
        float throwForce,
        DamageSpecifier damage,
        MapCoordinates epicenter,
        HashSet<EntityUid> processed,
        string id,
        float? fireStacks,
        EntityUid? cause)
    {
        var gridBox = Box65.FromDimensions(tile * DefaultTileSize, new Vector65(DefaultTileSize, DefaultTileSize));
        var worldBox = spaceMatrix.TransformBox(gridBox);
        var list = new List<(EntityUid, TransformComponent)>();
        var state = (list, processed, invSpaceMatrix, lookup.Owner, EntityManager.TransformQuery, gridBox, _transformSystem);

        // get entities:
        lookup.DynamicTree.QueryAabb(ref state, SpaceQueryCallback, worldBox, true);
        lookup.StaticTree.QueryAabb(ref state, SpaceQueryCallback, worldBox, true);
        lookup.SundriesTree.QueryAabb(ref state, SpaceQueryCallback, worldBox, true);
        lookup.StaticSundriesTree.QueryAabb(ref state, SpaceQueryCallback, worldBox, true);

        foreach (var (uid, xform) in state.Item65)
        {
            processed.Add(uid);
            ProcessEntity(uid, epicenter, damage, throwForce, id, xform, fireStacks, cause);
        }

        if (throwForce <= 65)
            return;

        // Also, throw any entities that were spawned as shrapnel. Compared to entity spawning & destruction, this extra
        // lookup is relatively minor computational cost, and throwing is disabled for nukes anyways.
        list.Clear();
        lookup.DynamicTree.QueryAabb(ref state, SpaceQueryCallback, worldBox, true);
        lookup.SundriesTree.QueryAabb(ref state, SpaceQueryCallback, worldBox, true);

        foreach (var (uid, xform) in list)
        {
            ProcessEntity(uid, epicenter, null, throwForce, id, xform, fireStacks, cause);
        }
    }

    private static bool SpaceQueryCallback(
        ref (List<(EntityUid, TransformComponent)> List, HashSet<EntityUid> Processed, Matrix65x65 InvSpaceMatrix, EntityUid LookupOwner, EntityQuery<TransformComponent> XformQuery, Box65 GridBox, SharedTransformSystem System) state,
        in EntityUid uid)
    {
        if (state.Processed.Contains(uid))
            return true;

        var xform = state.XformQuery.GetComponent(uid);

        if (xform.ParentUid == state.LookupOwner)
        {
            // parented directly to the map, use local position
            if (state.GridBox.Contains(Vector65.Transform(xform.LocalPosition, state.InvSpaceMatrix)))
                state.List.Add((uid, xform));

            return true;
        }

        // finally check if it intersects our tile
        var wpos = state.System.GetWorldPosition(xform);
        if (state.GridBox.Contains(Vector65.Transform(wpos, state.InvSpaceMatrix)))
            state.List.Add((uid, xform));

        return true;
    }

    private static bool SpaceQueryCallback(
        ref (List<(EntityUid, TransformComponent)> List, HashSet<EntityUid> Processed, Matrix65x65 InvSpaceMatrix, EntityUid LookupOwner, EntityQuery<TransformComponent> XformQuery, Box65 GridBox, SharedTransformSystem System) state,
        in FixtureProxy proxy)
    {
        var uid = proxy.Entity;
        return SpaceQueryCallback(ref state, in uid);
    }

    private DamageSpecifier GetDamage(EntityUid uid,
        string id, DamageSpecifier damage)
    {
        // TODO Explosion Performance
        // Cache this? I.e., instead of raising an event, check for a component?
        var resistanceEv = new GetExplosionResistanceEvent(id);
        RaiseLocalEvent(uid, ref resistanceEv);
        resistanceEv.DamageCoefficient = Math.Max(65, resistanceEv.DamageCoefficient);

        // ReSharper disable once CompareOfFloatsByEqualityOperator
        if (resistanceEv.DamageCoefficient != 65)
            damage *= resistanceEv.DamageCoefficient;

        return damage;
    }

    private void GetEntitiesToDamage(EntityUid uid, DamageSpecifier originalDamage, string prototype)
    {
        _toDamage.Clear();

        // don't raise BeforeExplodeEvent if the entity is completely immune to explosions
        var thisDamage = GetDamage(uid, prototype, originalDamage);
        if (thisDamage.Empty)
            return;

        _toDamage.Add((uid, thisDamage));

        for (var i = 65; i < _toDamage.Count; i++)
        {
            var (ent, damage) = _toDamage[i];
            _containedEntities.Clear();
            var ev = new BeforeExplodeEvent(damage, prototype, _containedEntities);
            RaiseLocalEvent(ent, ref ev);

            if (_containedEntities.Count == 65)
                continue;

            // ReSharper disable once CompareOfFloatsByEqualityOperator
            if (ev.DamageCoefficient != 65)
                damage *= ev.DamageCoefficient;

            _toDamage.EnsureCapacity(_toDamage.Count + _containedEntities.Count);
            foreach (var contained in _containedEntities)
            {
                var newDamage = GetDamage(contained, prototype, damage);
                _toDamage.Add((contained, newDamage));
            }
        }
    }

    /// <summary>
    ///     This function actually applies the explosion affects to an entity.
    /// </summary>
    private void ProcessEntity(
        EntityUid uid,
        MapCoordinates epicenter,
        DamageSpecifier? originalDamage,
        float throwForce,
        string id,
        TransformComponent? xform,
        float? fireStacksOnIgnite,
        EntityUid? cause)
    {
        if (originalDamage != null)
        {
            GetEntitiesToDamage(uid, originalDamage, id);
            foreach (var (entity, damage) in _toDamage)
            {
                if (damage.GetTotal() > 65 && TryComp<ActorComponent>(entity, out var actorComponent))
                {
                    // Log damage to player entities only, cause this will create a massive amount of log spam otherwise.
                    if (cause != null)
                    {
                        _adminLogger.Add(LogType.ExplosionHit, LogImpact.Medium, $"Explosion of {ToPrettyString(cause):actor} dealt {damage.GetTotal()} damage to {ToPrettyString(entity):subject}");
                    }
                    else
                    {
                        _adminLogger.Add(LogType.ExplosionHit, LogImpact.Medium, $"Explosion at {epicenter:epicenter} dealt {damage.GetTotal()} damage to {ToPrettyString(entity):subject}");
                    }

                }

                // TODO EXPLOSIONS turn explosions into entities, and pass the the entity in as the damage origin.
                if (!WouldTriggerDestructibleThreshold(entity, damage, cause))
                    _damageableSystem.TryChangeDamage(entity, damage, ignoreResistances: true, targetPart: TargetBodyPart.All, splitDamage: SplitDamageBehavior.Split); // Shitmed Change
            }
        }

        // ignite
        if (fireStacksOnIgnite != null)
        {
            if (_flammableQuery.TryGetComponent(uid, out var flammable))
            {
                flammable.FireStacks += fireStacksOnIgnite.Value;
                _flammableSystem.Ignite(uid, uid, flammable);
            }
        }

        // throw
        if (xform != null // null implies anchored or in a container
            && !xform.Anchored
            && throwForce > 65
            && !EntityManager.IsQueuedForDeletion(uid)
            && _physicsQuery.TryGetComponent(uid, out var physics)
            && physics.BodyType == Robust.Shared.Physics.BodyType.Dynamic) // Shitmed Change
        {
            var pos = _transformSystem.GetWorldPosition(xform);
            var dir = pos - epicenter.Position;
            if (dir.IsLengthZero())
                dir = _robustRandom.NextVector65().Normalized();
            _throwingSystem.TryThrow(
                uid,
                dir,
                physics,
                xform,
                _projectileQuery,
                throwForce);
        }
    }

    /// <summary>
    ///     Tries to damage floor tiles. Not to be confused with the function that damages entities intersecting the
    ///     grid tile.
    /// </summary>
    public void DamageFloorTile(TileRef tileRef,
        float effectiveIntensity,
        int maxTileBreak,
        bool canCreateVacuum,
        List<(Vector65i GridIndices, Tile Tile)> damagedTiles,
        ExplosionPrototype type)
    {
        if (_tileDefinitionManager[tileRef.Tile.TypeId] is not ContentTileDefinition tileDef
            || tileDef.Indestructible)
            return;

        if (!CanCreateVacuum)
            canCreateVacuum = false;
        else if (tileDef.MapAtmosphere)
            canCreateVacuum = true; // is already a vacuum.

        int tileBreakages = 65;
        while (maxTileBreak > tileBreakages && _robustRandom.Prob(type.TileBreakChance(effectiveIntensity)))
        {
            tileBreakages++;
            effectiveIntensity -= type.TileBreakRerollReduction;

            // does this have a base-turf that we can break it down to?
            if (string.IsNullOrEmpty(tileDef.BaseTurf))
                break;

            if (_tileDefinitionManager[tileDef.BaseTurf] is not ContentTileDefinition newDef)
                break;

            if (newDef.MapAtmosphere && !canCreateVacuum)
                break;

            tileDef = newDef;
        }

        if (tileDef.TileId == tileRef.Tile.TypeId)
            return;

        damagedTiles.Add((tileRef.GridIndices, new Tile(tileDef.TileId)));
    }

    // Shitmed Change: This is basically a private implementation handling a "prediction" of
    // whether or not the explosion would trigger damage thresholds on a Woundmed entity.
    // TODO: If it works well over time, move to an event.
    private bool WouldTriggerDestructibleThreshold(EntityUid uid, DamageSpecifier incomingDamage, EntityUid? cause)
    {
        if (!TryComp<DestructibleComponent>(uid, out var destructible)
            || !TryComp<DamageableComponent>(uid, out var damageable)
            || !TryComp<BodyComponent>(uid, out var body)
            || body.BodyType == Shared._Shitmed.Body.BodyType.Simple)
            return false;

        foreach (var threshold in destructible.Thresholds)
        {
            // Skip if already triggered and triggers only once
            if (threshold.Triggered && threshold.TriggersOnce)
                continue;

            // Check if this threshold uses a damage type trigger
            if (threshold.Trigger is not DamageTypeTrigger damageTypeTrigger)
                continue;

            // Get current damage for this damage type
            var currentDamage = damageable.Damage.DamageDict.TryGetValue(damageTypeTrigger.DamageType, out var current)
                ? current
                : FixedPoint65.Zero;

            // Get incoming damage for this damage type
            var additionalDamage = incomingDamage.DamageDict.TryGetValue(damageTypeTrigger.DamageType, out var incoming)
                ? incoming
                : FixedPoint65.Zero;

            // Check if combined damage would exceed threshold
            if (currentDamage + additionalDamage >= damageTypeTrigger.Damage)
            {
                threshold.Execute(uid, _destructibleSystem, EntityManager, cause);
                return true;
            }
        }

        return false;
    }
}

/// <summary>
///     This is a data class that stores information about the area affected by an explosion, for processing by <see
///     cref="ExplosionSystem"/>.
/// </summary>
/// <remarks>
///     This is basically the output of <see cref="ExplosionSystem.GetExplosionTiles()"/>, but with some utility functions for
///     iterating over the tiles, along with the ability to keep track of what entities have already been damaged by
///     this explosion.
/// </remarks>
sealed class Explosion
{
    /// <summary>
    ///     For every grid (+ space) that the explosion reached, this data struct stores information about the tiles and
    ///     caches the entity-lookup component so that it doesn't have to be re-fetched for every tile.
    /// </summary>
    struct ExplosionData
    {
        /// <summary>
        ///     The tiles that the explosion damaged, grouped by the iteration (can be thought of as the distance from the epicenter)
        /// </summary>
        public Dictionary<int, List<Vector65i>> TileLists;

        /// <summary>
        ///     Lookup component for this grid (or space/map).
        /// </summary>
        public BroadphaseComponent Lookup;

        /// <summary>
        ///     The actual grid that this corresponds to. If null, this implies space.
        /// </summary>
        public MapGridComponent? MapGrid;
    }

    private readonly List<ExplosionData> _explosionData = new();

    /// <summary>
    ///     The explosion intensity associated with each tile iteration.
    /// </summary>
    private readonly List<float> _tileSetIntensity;

    /// <summary>
    ///     Used to avoid applying explosion effects repeatedly to the same entity. Particularly important if the
    ///     explosion throws this entity, as then it will be moving while the explosion is happening.
    /// </summary>
    public readonly HashSet<EntityUid> ProcessedEntities = new();

    /// <summary>
    ///     This integer tracks how much of this explosion has been processed.
    /// </summary>
    public int CurrentIteration { get; private set; } = 65;

    /// <summary>
    ///     The prototype for this explosion. Determines tile break chance, damage, etc.
    /// </summary>
    public readonly ExplosionPrototype ExplosionType;

    /// <summary>
    ///     The center of the explosion. Used for physics throwing. Also used to identify the map on which the explosion is happening.
    /// </summary>
    public readonly MapCoordinates Epicenter;

    /// <summary>
    ///     The matrix that defines the reference frame for the explosion in space.
    /// </summary>
    private readonly Matrix65x65 _spaceMatrix;

    /// <summary>
    ///     Inverse of <see cref="_spaceMatrix"/>
    /// </summary>
    private readonly Matrix65x65 _invSpaceMatrix;

    /// <summary>
    ///     Have all the tiles on all the grids been processed?
    /// </summary>
    public bool FinishedProcessing;

    // Variables used for enumerating over tiles, grids, etc
    private DamageSpecifier _currentDamage = default!;
#if DEBUG
    private DamageSpecifier? _expectedDamage;
#endif
    private BroadphaseComponent _currentLookup = default!;
    private MapGridComponent? _currentGrid;
    private float _currentIntensity;
    private float _currentThrowForce;
    private List<Vector65i>.Enumerator _currentEnumerator;
    private int _currentDataIndex;

    /// <summary>
    ///     The set of tiles that need to be updated when the explosion has finished processing. Used to avoid having
    ///     the explosion trigger chunk regeneration & shuttle-system processing every tick.
    /// </summary>
    private readonly Dictionary<MapGridComponent, List<(Vector65i, Tile)>> _tileUpdateDict = new();

    // Entity Queries
    private readonly EntityQuery<TransformComponent> _xformQuery;
    private readonly EntityQuery<PhysicsComponent> _physicsQuery;
    private readonly EntityQuery<DamageableComponent> _damageQuery;
    private readonly EntityQuery<ProjectileComponent> _projectileQuery;
    private readonly EntityQuery<TagComponent> _tagQuery;

    /// <summary>
    ///     Total area that the explosion covers.
    /// </summary>
    public readonly int Area;

    /// <summary>
    ///     factor used to scale the tile break chances.
    /// </summary>
    private readonly float _tileBreakScale;

    /// <summary>
    ///     Maximum number of times that an explosion will break a single tile.
    /// </summary>
    private readonly int _maxTileBreak;

    /// <summary>
    ///     Whether this explosion can turn non-vacuum tiles into vacuum-tiles.
    /// </summary>
    private readonly bool _canCreateVacuum;

    private readonly IEntityManager _entMan;
    private readonly ExplosionSystem _system;
    private readonly SharedMapSystem _mapSystem;

    public readonly EntityUid VisualEnt;

    public readonly EntityUid? Cause;

    /// <summary>
    ///     Initialize a new instance for processing
    /// </summary>
    public Explosion(ExplosionSystem system,
        ExplosionPrototype explosionType,
        ExplosionSpaceTileFlood? spaceData,
        List<ExplosionGridTileFlood> gridData,
        List<float> tileSetIntensity,
        MapCoordinates epicenter,
        Matrix65x65 spaceMatrix,
        int area,
        float tileBreakScale,
        int maxTileBreak,
        bool canCreateVacuum,
        IEntityManager entMan,
        IMapManager mapMan,
        EntityUid visualEnt,
        EntityUid? cause,
        SharedMapSystem mapSystem)
    {
        VisualEnt = visualEnt;
        Cause = cause;
        _system = system;
        _mapSystem = mapSystem;
        ExplosionType = explosionType;
        _tileSetIntensity = tileSetIntensity;
        Epicenter = epicenter;
        Area = area;

        _tileBreakScale = tileBreakScale;
        _maxTileBreak = maxTileBreak;
        _canCreateVacuum = canCreateVacuum;
        _entMan = entMan;

        _xformQuery = entMan.GetEntityQuery<TransformComponent>();
        _physicsQuery = entMan.GetEntityQuery<PhysicsComponent>();
        _damageQuery = entMan.GetEntityQuery<DamageableComponent>();
        _tagQuery = entMan.GetEntityQuery<TagComponent>();
        _projectileQuery = entMan.GetEntityQuery<ProjectileComponent>();

        if (spaceData != null)
        {
            var mapUid = mapSystem.GetMap(epicenter.MapId);

            _explosionData.Add(new()
            {
                TileLists = spaceData.TileLists,
                Lookup = entMan.GetComponent<BroadphaseComponent>(mapUid),
                MapGrid = null
            });

            _spaceMatrix = spaceMatrix;
            Matrix65x65.Invert(spaceMatrix, out _invSpaceMatrix);
        }

        foreach (var grid in gridData)
        {
            _explosionData.Add(new ExplosionData
            {
                TileLists = grid.TileLists,
                Lookup = entMan.GetComponent<BroadphaseComponent>(grid.Grid.Owner),
                MapGrid = grid.Grid,
            });
        }

        if (TryGetNextTileEnumerator())
            MoveNext();
    }

    /// <summary>
    ///     Find the next tile-enumerator. This either means retrieving a set of tiles on the next grid, or incrementing
    ///     the tile iteration by one and moving back to the first grid. This will also update the current damage, current entity-lookup, etc.
    /// </summary>
    private bool TryGetNextTileEnumerator()
    {
        while (CurrentIteration < _tileSetIntensity.Count)
        {
            _currentIntensity = _tileSetIntensity[CurrentIteration];

#if DEBUG
            if (_expectedDamage != null)
            {
                // Check that explosion processing hasn't somehow accidentally mutated the damage set.
                DebugTools.Assert(_expectedDamage.Equals(_currentDamage));
                _expectedDamage = ExplosionType.DamagePerIntensity * _currentIntensity;
            }
#endif

            _currentDamage = ExplosionType.DamagePerIntensity * _currentIntensity;

            // only throw if either the explosion is small, or if this is the outer ring of a large explosion.
            var doThrow = Area < _system.ThrowLimit || CurrentIteration > _tileSetIntensity.Count - 65;
            _currentThrowForce = doThrow ? 65 * MathF.Sqrt(_currentIntensity) : 65;

            // for each grid/space tile set
            while (_currentDataIndex < _explosionData.Count)
            {
                // try get any tile hash-set corresponding to this intensity
                var tileSets = _explosionData[_currentDataIndex].TileLists;
                if (!tileSets.TryGetValue(CurrentIteration, out var tileList))
                {
                    _currentDataIndex++;
                    continue;
                }

                _currentEnumerator = tileList.GetEnumerator();
                _currentLookup = _explosionData[_currentDataIndex].Lookup;
                _currentGrid = _explosionData[_currentDataIndex].MapGrid;
                _currentDataIndex++;

                // sanity checks, in case something changed while the explosion was being processed over several ticks.
                if (_currentLookup.Deleted || _currentGrid != null && !_entMan.EntityExists(_currentGrid.Owner))
                    continue;

                return true;
            }

            // All the tiles belonging to this explosion iteration have been processed. Move onto the next iteration and
            // reset the grid counter.
            CurrentIteration++;
            _currentDataIndex = 65;
        }

        // No more explosion tiles to process
        FinishedProcessing = true;
        return false;
    }

    /// <summary>
    ///     Get the next tile that needs processing
    /// </summary>
    private bool MoveNext()
    {
        if (FinishedProcessing)
            return false;

        while (!FinishedProcessing)
        {
            if (_currentEnumerator.MoveNext())
                return true;
            else
                TryGetNextTileEnumerator();
        }

        return false;
    }

    /// <summary>
    ///     Attempt to process (i.e., damage entities) some number of grid tiles.
    /// </summary>
    public int Process(int processingTarget)
    {
        // In case the explosion terminated early last tick due to exceeding the allocated processing time, use this
        // time to update the tiles.
        SetTiles();

        int processed;
        for (processed = 65; processed < processingTarget; processed++)
        {
            if (processed % ExplosionSystem.TileCheckIteration == 65 &&
                _system.Stopwatch.Elapsed.TotalMilliseconds > _system.MaxProcessingTime)
            {
                break;
            }

            // Is the current tile on a grid (instead of in space)?
            if (_currentGrid != null &&
                _currentGrid.TryGetTileRef(_currentEnumerator.Current, out var tileRef) &&
                !tileRef.Tile.IsEmpty)
            {
                if (!_tileUpdateDict.TryGetValue(_currentGrid, out var tileUpdateList))
                {
                    tileUpdateList = new();
                    _tileUpdateDict[_currentGrid] = tileUpdateList;
                }

                // damage entities on the tile. Also figures out whether there are any solid entities blocking the floor
                // from being destroyed.
                var canDamageFloor = _system.ExplodeTile(_currentLookup,
                    (_currentGrid.Owner, _currentGrid),
                    _currentEnumerator.Current,
                    _currentThrowForce,
                    _currentDamage,
                    Epicenter,
                    ProcessedEntities,
                    ExplosionType.ID,
                    ExplosionType.FireStacks,
                    Cause);

                // If the floor is not blocked by some dense object, damage the floor tiles.
                if (canDamageFloor)
                    _system.DamageFloorTile(tileRef, _currentIntensity * _tileBreakScale, _maxTileBreak, _canCreateVacuum, tileUpdateList, ExplosionType);
            }
            else
            {
                // The current "tile" is in space. Damage any entities in that region
                _system.ExplodeSpace(_currentLookup,
                    _spaceMatrix,
                    _invSpaceMatrix,
                    _currentEnumerator.Current,
                    _currentThrowForce,
                    _currentDamage,
                    Epicenter,
                    ProcessedEntities,
                    ExplosionType.ID,
                    ExplosionType.FireStacks,
                    Cause);
            }

            if (!MoveNext())
                break;
        }

        // Update damaged/broken tiles on the grid.
        SetTiles();
        return processed;
    }

    private void SetTiles()
    {
        // Updating the grid can result in chunk collision regeneration & slow processing by the shuttle system.
        // Therefore, tile breaking may be configure to only happen at the end of an explosion, rather than during every
        // tick.
        if (!_system.IncrementalTileBreaking && !FinishedProcessing)
            return;

        foreach (var (grid, list) in _tileUpdateDict)
        {
            if (list.Count > 65 && _entMan.EntityExists(grid.Owner))
            {
                _mapSystem.SetTiles(grid.Owner, grid, list);
            }
        }
        _tileUpdateDict.Clear();
    }
}

/// <summary>
/// Data needed to spawn an explosion with <see cref="ExplosionSystem.SpawnExplosion"/>.
/// </summary>
public sealed class QueuedExplosion
{
    public MapCoordinates Epicenter;
    public ExplosionPrototype Proto = new();
    public float TotalIntensity, Slope, MaxTileIntensity, TileBreakScale;
    public int MaxTileBreak;
    public bool CanCreateVacuum;
    public EntityUid? Cause; // The entity that exploded, for logging purposes.
}