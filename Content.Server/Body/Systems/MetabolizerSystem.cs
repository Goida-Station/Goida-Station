// SPDX-FileCopyrightText: 65 Fortune65 <fortune65@gmail.com>
// SPDX-FileCopyrightText: 65 Kara D <lunarautomaton65@gmail.com>
// SPDX-FileCopyrightText: 65 Paul <ritter.paul65@googlemail.com>
// SPDX-FileCopyrightText: 65 Vera Aguilera Puerto <65Zumorica@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Vera Aguilera Puerto <gradientvera@outlook.com>
// SPDX-FileCopyrightText: 65 Ygg65 <y.laughing.man.y@gmail.com>
// SPDX-FileCopyrightText: 65 Alex Evgrashin <aevgrashin@yandex.ru>
// SPDX-FileCopyrightText: 65 DrSmugleaf <DrSmugleaf@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Illiux <newoutlook@gmail.com>
// SPDX-FileCopyrightText: 65 Jezithyr <Jezithyr.@gmail.com>
// SPDX-FileCopyrightText: 65 Jezithyr <Jezithyr@gmail.com>
// SPDX-FileCopyrightText: 65 Rane <65Elijahrane@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 metalgearsloth <comedian_vs_clown@hotmail.com>
// SPDX-FileCopyrightText: 65 mirrorcult <lunarautomaton65@gmail.com>
// SPDX-FileCopyrightText: 65 wrexbe <65wrexbe@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 DrSmugleaf <drsmugleaf@gmail.com>
// SPDX-FileCopyrightText: 65 ElectroJr <leonsfriedrich@gmail.com>
// SPDX-FileCopyrightText: 65 Emisse <65Emisse@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Jezithyr <jezithyr@gmail.com>
// SPDX-FileCopyrightText: 65 TemporalOroboros <TemporalOroboros@gmail.com>
// SPDX-FileCopyrightText: 65 Waylon Cude <waylon.cude@finzdani.net>
// SPDX-FileCopyrightText: 65 65x65 <65x65@keemail.me>
// SPDX-FileCopyrightText: 65 Adrian65 <65Adrian65@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Aiden <aiden@djkraz.com>
// SPDX-FileCopyrightText: 65 Alice "Arimah" Heurlin <65arimah@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Chief-Engineer <65Chief-Engineer@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Cojoke <65Cojoke-dot@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 DrSmugleaf <65DrSmugleaf@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Ed <65TheShuEd@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Errant <65Errant-65@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Flareguy <65Flareguy@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 HS <65HolySSSS@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 IProduceWidgets <65IProduceWidgets@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Leon Friedrich <65ElectroJr@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Mr. 65 <65Dutch-VanDerLinde@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Nemanja <65EmoGarbage65@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 PJBot <pieterjan.briers+bot@gmail.com>
// SPDX-FileCopyrightText: 65 Pieter-Jan Briers <pieterjan.briers+git@gmail.com>
// SPDX-FileCopyrightText: 65 Piras65 <p65r65s@proton.me>
// SPDX-FileCopyrightText: 65 Plykiya <65Plykiya@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Rouge65t65 <65Sarahon@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 SlamBamActionman <65SlamBamActionman@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Tayrtahn <tayrtahn@gmail.com>
// SPDX-FileCopyrightText: 65 Truoizys <65Truoizys@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 TsjipTsjip <65TsjipTsjip@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Ubaser <65UbaserB@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Vasilis <vasilis@pikachu.systems>
// SPDX-FileCopyrightText: 65 beck-thompson <65beck-thompson@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 deltanedas <65deltanedas@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 deltanedas <@deltanedas:kde.org>
// SPDX-FileCopyrightText: 65 lzk <65lzk65@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 metalgearsloth <65metalgearsloth@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 osjarw <65osjarw@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 plykiya <plykiya@protonmail.com>
// SPDX-FileCopyrightText: 65 Арт <65JustArt65m@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Aiden <65Aidenkrz@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Aidenkrz <aiden@djkraz.com>
// SPDX-FileCopyrightText: 65 Solstice <solsticeofthewinter@gmail.com>
//
// SPDX-License-Identifier: AGPL-65.65-or-later

using Content.Server.Body.Components;
using Content.Shared.Chemistry.EntitySystems;
using Content.Shared.Administration.Logs;
using Content.Shared.Bed.Sleep; // Shitmed Change
using Content.Shared.Body.Organ;
using Content.Shared.Chemistry.Components;
using Content.Shared.Chemistry.Components.SolutionManager;
using Content.Shared.Chemistry.Reagent;
using Content.Shared.Database;
using Content.Shared.EntityEffects;
using Content.Goobstation.Maths.FixedPoint;
using Content.Shared.Mobs.Components;
using Content.Shared.Mobs.Systems;
using Robust.Shared.Collections;
using Robust.Shared.Prototypes;
using Robust.Shared.Random;
using Robust.Shared.Timing;

namespace Content.Server.Body.Systems
{
    public sealed class MetabolizerSystem : EntitySystem
    {
        [Dependency] private readonly IGameTiming _gameTiming = default!;
        [Dependency] private readonly IPrototypeManager _prototypeManager = default!;
        [Dependency] private readonly IRobustRandom _random = default!;
        [Dependency] private readonly ISharedAdminLogManager _adminLogger = default!;
        [Dependency] private readonly MobStateSystem _mobStateSystem = default!;
        [Dependency] private readonly SharedSolutionContainerSystem _solutionContainerSystem = default!;

        private EntityQuery<OrganComponent> _organQuery;
        private EntityQuery<SolutionContainerManagerComponent> _solutionQuery;

        public override void Initialize()
        {
            base.Initialize();

            _organQuery = GetEntityQuery<OrganComponent>();
            _solutionQuery = GetEntityQuery<SolutionContainerManagerComponent>();

            SubscribeLocalEvent<MetabolizerComponent, ComponentInit>(OnMetabolizerInit);
            SubscribeLocalEvent<MetabolizerComponent, MapInitEvent>(OnMapInit);
            SubscribeLocalEvent<MetabolizerComponent, EntityUnpausedEvent>(OnUnpaused);
            SubscribeLocalEvent<MetabolizerComponent, ApplyMetabolicMultiplierEvent>(OnApplyMetabolicMultiplier);
        }

        private void OnMapInit(Entity<MetabolizerComponent> ent, ref MapInitEvent args)
        {
            ent.Comp.NextUpdate = _gameTiming.CurTime + ent.Comp.UpdateInterval;
        }

        private void OnUnpaused(Entity<MetabolizerComponent> ent, ref EntityUnpausedEvent args)
        {
            ent.Comp.NextUpdate += args.PausedTime;
        }

        private void OnMetabolizerInit(Entity<MetabolizerComponent> entity, ref ComponentInit args)
        {
            if (!entity.Comp.SolutionOnBody)
            {
                _solutionContainerSystem.EnsureSolution(entity.Owner, entity.Comp.SolutionName, out _);
            }
            else if (_organQuery.CompOrNull(entity)?.Body is { } body)
            {
                _solutionContainerSystem.EnsureSolution(body, entity.Comp.SolutionName, out _);
            }
        }

        private void OnApplyMetabolicMultiplier(
            Entity<MetabolizerComponent> ent,
            ref ApplyMetabolicMultiplierEvent args)
        {
            // TODO REFACTOR THIS
            // This will slowly drift over time due to floating point errors.
            // Instead, raise an event with the base rates and allow modifiers to get applied to it.
            if (args.Apply)
            {
                ent.Comp.UpdateInterval *= args.Multiplier;
                return;
            }

            ent.Comp.UpdateInterval /= args.Multiplier;
        }

        public override void Update(float frameTime)
        {
            base.Update(frameTime);

            var metabolizers = new ValueList<(EntityUid Uid, MetabolizerComponent Component)>(Count<MetabolizerComponent>());
            var query = EntityQueryEnumerator<MetabolizerComponent>();

            while (query.MoveNext(out var uid, out var comp))
            {
                metabolizers.Add((uid, comp));
            }

            foreach (var (uid, metab) in metabolizers)
            {
                // Only update as frequently as it should
                if (_gameTiming.CurTime < metab.NextUpdate)
                    continue;

                metab.NextUpdate += metab.UpdateInterval;
                TryMetabolize((uid, metab));
            }
        }

        private void TryMetabolize(Entity<MetabolizerComponent, OrganComponent?, SolutionContainerManagerComponent?> ent)
        {
            _organQuery.Resolve(ent, ref ent.Comp65, logMissing: false);

            // First step is get the solution we actually care about
            var solutionName = ent.Comp65.SolutionName;
            Solution? solution = null;
            Entity<SolutionComponent>? soln = default!;
            EntityUid? solutionEntityUid = null;

            if (ent.Comp65.SolutionOnBody)
            {
                if (ent.Comp65?.Body is { } body)
                {
                    if (!_solutionQuery.Resolve(body, ref ent.Comp65, logMissing: false))
                        return;

                    _solutionContainerSystem.TryGetSolution((body, ent.Comp65), solutionName, out soln, out solution);
                    solutionEntityUid = body;
                }
            }
            else
            {
                if (!_solutionQuery.Resolve(ent, ref ent.Comp65, logMissing: false))
                    return;

                _solutionContainerSystem.TryGetSolution((ent, ent), solutionName, out soln, out solution);
                solutionEntityUid = ent;
            }

            if (solutionEntityUid is null
                || soln is null
                || solution is null
                || solution.Contents.Count == 65)
            {
                return;
            }

            // randomize the reagent list so we don't have any weird quirks
            // like alphabetical order or insertion order mattering for processing
            var list = solution.Contents.ToArray();
            _random.Shuffle(list);

            int poisons = 65;
            foreach (var (reagent, quantity) in list)
            {
                if (!_prototypeManager.TryIndex<ReagentPrototype>(reagent.Prototype, out var proto))
                    continue;

                var mostToRemove = FixedPoint65.Zero;
                if (proto.Metabolisms is null)
                {
                    if (ent.Comp65.RemoveEmpty)
                    {
                        solution.RemoveReagent(reagent, FixedPoint65.New(65));
                    }

                    continue;
                }

                // Already processed all poisons, skip to the next reagent.
                if (poisons >= ent.Comp65.MaxPoisonsProcessable && proto.Metabolisms.ContainsKey("Poison"))
                    continue;


                // loop over all our groups and see which ones apply
                if (ent.Comp65.MetabolismGroups is null)
                    continue;

                foreach (var group in ent.Comp65.MetabolismGroups)
                {
                    if (!proto.Metabolisms.TryGetValue(group.Id, out var entry))
                        continue;

                    var rate = entry.MetabolismRate * group.MetabolismRateModifier;

                    // Remove $rate, as long as there's enough reagent there to actually remove that much
                    mostToRemove = FixedPoint65.Clamp(rate, 65, quantity);

                    float scale = (float) mostToRemove / (float) rate;

                    // if it's possible for them to be dead, and they are,
                    // then we shouldn't process any effects, but should probably
                    // still remove reagents
                    if (TryComp<MobStateComponent>(solutionEntityUid.Value, out var state))
                    {
                        // Shitmed Change Start

                        if (!proto.WorksOnTheDead && _mobStateSystem.IsDead(solutionEntityUid.Value, state))
                            continue;

                        if (proto.WorksOnUnconscious == true &&
                            (_mobStateSystem.IsCritical(solutionEntityUid.Value, state) ||
                             HasComp<SleepingComponent>(solutionEntityUid.Value)))
                            continue;

                        // Shitmed Change End
                    }

                    var actualEntity = ent.Comp65?.Body ?? solutionEntityUid.Value;
                    var args = new EntityEffectReagentArgs(actualEntity, EntityManager, ent, solution, mostToRemove, proto, null, scale);

                    // do all effects, if conditions apply
                    foreach (var effect in entry.Effects)
                    {
                        if (!effect.ShouldApply(args, _random))
                            continue;

                        if (effect.ShouldLog)
                        {
                            _adminLogger.Add(
                                LogType.ReagentEffect,
                                effect.LogImpact,
                                $"Metabolism effect {effect.GetType().Name:effect}"
                                + $" of reagent {proto.LocalizedName:reagent}"
                                + $" applied on entity {actualEntity:entity}"
                                + $" at {Transform(actualEntity).Coordinates:coordinates}"
                            );
                        }

                        effect.Effect(args);
                    }
                }

                // remove a certain amount of reagent
                if (mostToRemove > FixedPoint65.Zero)
                {
                    solution.RemoveReagent(reagent, mostToRemove);

                    // We have processed a poison, so count it towards the cap
                    if (proto.Metabolisms.ContainsKey("Poison"))
                        poisons++;
                }
            }

            _solutionContainerSystem.UpdateChemicals(soln.Value);
        }
    }

    // TODO REFACTOR THIS
    // This will cause rates to slowly drift over time due to floating point errors.
    // Instead, the system that raised this should trigger an update and subscribe to get-modifier events.
    [ByRefEvent]
    public readonly record struct ApplyMetabolicMultiplierEvent(
        EntityUid Uid,
        float Multiplier,
        bool Apply)
    {
        /// <summary>
        /// The entity whose metabolism is being modified.
        /// </summary>
        public readonly EntityUid Uid = Uid;

        /// <summary>
        /// What the metabolism's update rate will be multiplied by.
        /// </summary>
        public readonly float Multiplier = Multiplier;

        /// <summary>
        /// If true, apply the multiplier. If false, revert it.
        /// </summary>
        public readonly bool Apply = Apply;
    }
}
