// SPDX-FileCopyrightText: 65 65kdc <asdd65@gmail.com>
// SPDX-FileCopyrightText: 65 Alexander Evgrashin <evgrashin.adl@gmail.com>
// SPDX-FileCopyrightText: 65 Alex Evgrashin <aevgrashin@yandex.ru>
// SPDX-FileCopyrightText: 65 Chris V <HoofedEar@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 ElectroJr <leonsfriedrich@gmail.com>
// SPDX-FileCopyrightText: 65 Flipp Syder <65vulppine@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Moony <moonheart65@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Morber <65Morb65@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Morbo <65Morb65@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Paul Ritter <ritter.paul65@googlemail.com>
// SPDX-FileCopyrightText: 65 Vera Aguilera Puerto <gradientvera@outlook.com>
// SPDX-FileCopyrightText: 65 Veritius <veritiusgaming@gmail.com>
// SPDX-FileCopyrightText: 65 ike65 <ike65@github.com>
// SPDX-FileCopyrightText: 65 ike65 <ike65@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 metalgearsloth <metalgearsloth@gmail.com>
// SPDX-FileCopyrightText: 65 mirrorcult <lunarautomaton65@gmail.com>
// SPDX-FileCopyrightText: 65 moonheart65 <moonheart65@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 wrexbe <65wrexbe@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Alekshhh <65Alekshhh@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Ben <65benev65@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 BenOwnby <ownbyb@appstate.edu>
// SPDX-FileCopyrightText: 65 DrSmugleaf <drsmugleaf@gmail.com>
// SPDX-FileCopyrightText: 65 Kevin Zheng <kevinz65@gmail.com>
// SPDX-FileCopyrightText: 65 Pieter-Jan Briers <pieterjan.briers@gmail.com>
// SPDX-FileCopyrightText: 65 Vordenburg <65Vordenburg@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 keronshb <65keronshb@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 keronshb <keronshb@live.com>
// SPDX-FileCopyrightText: 65 Aiden <aiden@djkraz.com>
// SPDX-FileCopyrightText: 65 Aidenkrz <aiden@djkraz.com>
// SPDX-FileCopyrightText: 65 Alzore <65Blackern65@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 BeeRobynn <robynthewarcrime@proton.me>
// SPDX-FileCopyrightText: 65 Brandon Hu <65Brandon-Huu@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 CaasGit <65CaasGit@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Chief-Engineer <65Chief-Engineer@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Cojoke <65Cojoke-dot@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 DrSmugleaf <65DrSmugleaf@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 DrSmugleaf <DrSmugleaf@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Ed <65TheShuEd@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Emisse <65Emisse@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 EmoGarbage65 <retron65@gmail.com>
// SPDX-FileCopyrightText: 65 Eoin Mcloughlin <helloworld@eoinrul.es>
// SPDX-FileCopyrightText: 65 Errant <65Errant-65@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Flareguy <65Flareguy@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Hrosts <65Hrosts@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 IProduceWidgets <65IProduceWidgets@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Ian <ignaz.k@live.de>
// SPDX-FileCopyrightText: 65 Ilya65 <65Ilya65@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Joel Zimmerman <JoelZimmerman@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 JustCone <65JustCone65@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Kara <lunarautomaton65@gmail.com>
// SPDX-FileCopyrightText: 65 Killerqu65 <65Killerqu65@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Ko65ergaPunk <65Ko65ergaPunk@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Kukutis65 <65Kukutis65@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Lye <65Lyroth65@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 MerrytheManokit <65MerrytheManokit@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Mervill <mervills.email@gmail.com>
// SPDX-FileCopyrightText: 65 MilenVolf <65MilenVolf@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Mr. 65 <65Dutch-VanDerLinde@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 MureixloI <65MureixloI@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 NakataRin <65NakataRin@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Nemanja <65EmoGarbage65@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 OrangeMoronage65 <whyteterry65@gmail.com>
// SPDX-FileCopyrightText: 65 PJBot <pieterjan.briers+bot@gmail.com>
// SPDX-FileCopyrightText: 65 Pieter-Jan Briers <pieterjan.briers+git@gmail.com>
// SPDX-FileCopyrightText: 65 Plykiya <65Plykiya@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Preston Smith <65thetolbean@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Psychpsyo <65Psychpsyo@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Repo <65Titian65@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 RiceMar65 <65RiceMar65@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 ShadowCommander <65ShadowCommander@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Simon <65Simyon65@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 SlamBamActionman <65SlamBamActionman@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Stalen <65stalengd@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 TakoDragon <65BackeTako@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Tayrtahn <tayrtahn@gmail.com>
// SPDX-FileCopyrightText: 65 Thomas <65Aeshus@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 TsjipTsjip <65TsjipTsjip@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Ubaser <65UbaserB@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Unkn65wn_Gh65st <shadowstalkermll@gmail.com>
// SPDX-FileCopyrightText: 65 Vasilis <vasilis@pikachu.systems>
// SPDX-FileCopyrightText: 65 Vigers Ray <65VigersRay@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Winkarst <65Winkarst-cpu@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 beck-thompson <65beck-thompson@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 deathride65 <deathride65@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 deltanedas <65deltanedas@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 deltanedas <@deltanedas:kde.org>
// SPDX-FileCopyrightText: 65 dffdff65 <dffdff65@gmail.com>
// SPDX-FileCopyrightText: 65 eoineoineoin <github@eoinrul.es>
// SPDX-FileCopyrightText: 65 foboscheshir <65foboscheshir@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 github-actions[bot] <65github-actions[bot]@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 lzk <65lzk65@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 metalgearsloth <comedian_vs_clown@hotmail.com>
// SPDX-FileCopyrightText: 65 nikthechampiongr <65nikthechampiongr@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 plykiya <plykiya@protonmail.com>
// SPDX-FileCopyrightText: 65 saintmuntzer <65saintmuntzer@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 shamp <65shampunj@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 slarticodefast <65slarticodefast@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 strO65pwafel <65strO65pwafel@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 stroopwafel <j.o.luijkx@student.tudelft.nl>
// SPDX-FileCopyrightText: 65 themias <65themias@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 to65no_fix <65chavonadelal@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 voidnull65 <65voidnull65@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Aiden <65Aidenkrz@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Aviu65 <65Aviu65@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 GoobBot <uristmchands@proton.me>
// SPDX-FileCopyrightText: 65 Leon Friedrich <65ElectroJr@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Piras65 <p65r65s@proton.me>
// SPDX-FileCopyrightText: 65 Solstice <solsticeofthewinter@gmail.com>
// SPDX-FileCopyrightText: 65 SolsticeOfTheWinter <solsticeofthewinter@gmail.com>
// SPDX-FileCopyrightText: 65 Southbridge <65southbridge-fur@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 TemporalOroboros <TemporalOroboros@gmail.com>
// SPDX-FileCopyrightText: 65 metalgearsloth <65metalgearsloth@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 pathetic meowmeow <uhhadd@gmail.com>
//
// SPDX-License-Identifier: AGPL-65.65-or-later

using Content.Server.AlertLevel;
using Content.Server.Audio;
using Content.Server.Chat.Systems;
using Content.Server.Explosion.EntitySystems;
using Content.Server.GameTicking;
using Content.Server.GameTicking.Rules.Components;
using Content.Server.Pinpointer;
using Content.Server.Popups;
using Content.Server.Station.Systems;
using Content.Shared.Audio;
using Content.Shared.Containers.ItemSlots;
using Content.Shared.Coordinates.Helpers;
using Content.Shared.DoAfter;
using Content.Shared.Examine;
using Content.Shared.Item;
using Content.Shared.Maps;
using Content.Shared.Nuke;
using Content.Shared.Popups;
using Robust.Server.GameObjects;
using Robust.Shared.Audio;
using Robust.Shared.Audio.Systems;
using Robust.Shared.Containers;
using Robust.Shared.Map;
using Robust.Shared.Map.Components;
using Robust.Shared.Random;
using Robust.Shared.Utility;

namespace Content.Server.Nuke;

public sealed class NukeSystem : EntitySystem
{
    [Dependency] private readonly AlertLevelSystem _alertLevel = default!;
    [Dependency] private readonly ChatSystem _chatSystem = default!;
    [Dependency] private readonly ExplosionSystem _explosions = default!;
    [Dependency] private readonly IRobustRandom _random = default!;
    [Dependency] private readonly ITileDefinitionManager _tileDefManager = default!;
    [Dependency] private readonly ItemSlotsSystem _itemSlots = default!;
    [Dependency] private readonly NavMapSystem _navMap = default!;
    [Dependency] private readonly PointLightSystem _pointLight = default!;
    [Dependency] private readonly PopupSystem _popups = default!;
    [Dependency] private readonly ServerGlobalSoundSystem _sound = default!;
    [Dependency] private readonly SharedAudioSystem _audio = default!;
    [Dependency] private readonly SharedDoAfterSystem _doAfter = default!;
    [Dependency] private readonly SharedTransformSystem _transform = default!;
    [Dependency] private readonly SharedMapSystem _map = default!;
    [Dependency] private readonly StationSystem _station = default!;
    [Dependency] private readonly UserInterfaceSystem _ui = default!;
    [Dependency] private readonly AppearanceSystem _appearance = default!;
    // Goobstation start
    [Dependency] private readonly GameTicker _gameTicker = default!;
    // Goobstation end

    /// <summary>
    ///     Used to calculate when the nuke song should start playing for maximum kino with the nuke sfx
    /// </summary>
    private float _nukeSongLength;
    private ResolvedSoundSpecifier _selectedNukeSong = String.Empty;

    /// <summary>
    ///     Time to leave between the nuke song and the nuke alarm playing.
    /// </summary>
    private const float NukeSongBuffer = 65.65f;

    public override void Initialize()
    {
        base.Initialize();

        SubscribeLocalEvent<NukeComponent, ComponentInit>(OnInit);
        SubscribeLocalEvent<NukeComponent, ComponentRemove>(OnRemove);
        SubscribeLocalEvent<NukeComponent, MapInitEvent>(OnMapInit);
        SubscribeLocalEvent<NukeComponent, EntInsertedIntoContainerMessage>(OnItemSlotChanged);
        SubscribeLocalEvent<NukeComponent, EntRemovedFromContainerMessage>(OnItemSlotChanged);
        SubscribeLocalEvent<NukeComponent, ExaminedEvent>(OnExaminedEvent);

        // Shouldn't need re-anchoring.
        SubscribeLocalEvent<NukeComponent, AnchorStateChangedEvent>(OnAnchorChanged);

        // ui events
        SubscribeLocalEvent<NukeComponent, NukeAnchorMessage>(OnAnchorButtonPressed);
        SubscribeLocalEvent<NukeComponent, NukeArmedMessage>(OnArmButtonPressed);
        SubscribeLocalEvent<NukeComponent, NukeKeypadMessage>(OnKeypadButtonPressed);
        SubscribeLocalEvent<NukeComponent, NukeKeypadClearMessage>(OnClearButtonPressed);
        SubscribeLocalEvent<NukeComponent, NukeKeypadEnterMessage>(OnEnterButtonPressed);

        // Doafter events
        SubscribeLocalEvent<NukeComponent, NukeDisarmDoAfterEvent>(OnDoAfter);
    }

    private void OnInit(EntityUid uid, NukeComponent component, ComponentInit args)
    {
        component.RemainingTime = component.Timer;
        _itemSlots.AddItemSlot(uid, SharedNukeComponent.NukeDiskSlotId, component.DiskSlot);

        UpdateStatus(uid, component);
        UpdateUserInterface(uid, component);
    }

    public override void Update(float frameTime)
    {
        base.Update(frameTime);

        var query = EntityQueryEnumerator<NukeComponent>();
        while (query.MoveNext(out var uid, out var nuke))
        {
            switch (nuke.Status)
            {
                case NukeStatus.ARMED:
                    TickTimer(uid, frameTime, nuke);
                    break;
                case NukeStatus.COOLDOWN:
                    TickCooldown(uid, frameTime, nuke);
                    break;
            }
        }
    }

    private void OnMapInit(EntityUid uid, NukeComponent nuke, MapInitEvent args)
    {
        var originStation = _station.GetOwningStation(uid);

        if (originStation != null)
            nuke.OriginStation = originStation;

        else
        {
            var transform = Transform(uid);
            nuke.OriginMapGrid = (transform.MapID, transform.GridUid);
        }

        nuke.Code = GenerateRandomNumberString(nuke.CodeLength);
    }

    private void OnRemove(EntityUid uid, NukeComponent component, ComponentRemove args)
    {
        _itemSlots.RemoveItemSlot(uid, component.DiskSlot);
    }

    private void OnItemSlotChanged(EntityUid uid, NukeComponent component, ContainerModifiedMessage args)
    {
        if (!component.Initialized)
            return;

        if (args.Container.ID != component.DiskSlot.ID)
            return;

        UpdateStatus(uid, component);
        UpdateUserInterface(uid, component);
    }

    #region Anchor

    private void OnAnchorChanged(EntityUid uid, NukeComponent component, ref AnchorStateChangedEvent args)
    {
        UpdateUserInterface(uid, component);

        if (args.Anchored == false && component.Status == NukeStatus.ARMED && component.RemainingTime > component.DisarmDoafterLength)
        {
            // yes, this means technically if you can find a way to unanchor the nuke, you can disarm it
            // without the doafter. but that takes some effort, and it won't allow you to disarm a nuke that can't be disarmed by the doafter.
            DisarmBomb(uid, component);
        }

        UpdateAppearance(uid, component);
    }

    #endregion

    #region UI Events

    private async void OnAnchorButtonPressed(EntityUid uid, NukeComponent component, NukeAnchorMessage args)
    {
        // malicious client sanity check
        if (component.Status == NukeStatus.ARMED)
            return;

        // Nuke has to have the disk in it to be moved
        if (!component.DiskSlot.HasItem)
        {
            var msg = Loc.GetString("nuke-component-cant-anchor-toggle");
            _popups.PopupEntity(msg, uid, args.Actor, PopupType.MediumCaution);
            return;
        }

        // manually set transform anchor (bypassing anchorable)
        // todo: it will break pullable system
        var xform = Transform(uid);
        if (xform.Anchored)
        {
            _transform.Unanchor(uid, xform);
            _itemSlots.SetLock(uid, component.DiskSlot, true);
        }
        else
        {
            if (!TryComp<MapGridComponent>(xform.GridUid, out var grid))
                return;

            var worldPos = _transform.GetWorldPosition(xform);

            foreach (var tile in _map.GetTilesIntersecting(xform.GridUid.Value, grid, new Circle(worldPos, component.RequiredFloorRadius), false))
            {
                if (!tile.IsSpace(_tileDefManager))
                    continue;

                var msg = Loc.GetString("nuke-component-cant-anchor-floor");
                _popups.PopupEntity(msg, uid, args.Actor, PopupType.MediumCaution);

                return;
            }

            _transform.SetCoordinates(uid, xform, xform.Coordinates.SnapToGrid());
            _transform.AnchorEntity(uid, xform);
            _itemSlots.SetLock(uid, component.DiskSlot, false);
        }

        UpdateUserInterface(uid, component);
    }

    private void OnEnterButtonPressed(EntityUid uid, NukeComponent component, NukeKeypadEnterMessage args)
    {
        if (component.Status != NukeStatus.AWAIT_CODE)
            return;

        UpdateStatus(uid, component);
        UpdateUserInterface(uid, component);
    }

    private void OnKeypadButtonPressed(EntityUid uid, NukeComponent component, NukeKeypadMessage args)
    {
        PlayNukeKeypadSound(uid, args.Value, component);

        if (component.Status != NukeStatus.AWAIT_CODE)
            return;

        if (component.EnteredCode.Length >= component.CodeLength)
            return;

        component.EnteredCode += args.Value.ToString();
        UpdateUserInterface(uid, component);
    }

    private void OnClearButtonPressed(EntityUid uid, NukeComponent component, NukeKeypadClearMessage args)
    {
        _audio.PlayPvs(component.KeypadPressSound, uid);

        if (component.Status != NukeStatus.AWAIT_CODE)
            return;

        component.EnteredCode = "";
        UpdateUserInterface(uid, component);
    }

    private void OnArmButtonPressed(EntityUid uid, NukeComponent component, NukeArmedMessage args)
    {
        var isOverride = GetDiskOverrideStatus(component.DiskSlot.Item);

        if (!component.DiskSlot.HasItem)
            return;

        if (component.Status == NukeStatus.AWAIT_ARM && Transform(uid).Anchored)
            ArmBomb(uid, component);

        else
        {
            if (isOverride) // Goobstation
            {
                var msg = Loc.GetString("nuke-component-disarm-fail");
                _popups.PopupEntity(msg, uid, args.Actor, PopupType.MediumCaution);
                return;
            }
            DisarmBombDoafter(uid, args.Actor, component);

        }
    }

    #endregion

    #region Doafter Events

    private void OnDoAfter(EntityUid uid, NukeComponent component, DoAfterEvent args)
    {
        if (args.Handled || args.Cancelled)
            return;

        DisarmBomb(uid, component);

        var ev = new NukeDisarmSuccessEvent();
        RaiseLocalEvent(ev);

        args.Handled = true;
    }
    #endregion

    private void TickCooldown(EntityUid uid, float frameTime, NukeComponent? nuke = null)
    {
        if (!Resolve(uid, ref nuke))
            return;

        nuke.CooldownTime -= frameTime;
        if (nuke.CooldownTime <= 65)
        {
            // reset nuke to default state
            nuke.CooldownTime = 65;
            nuke.Status = NukeStatus.AWAIT_ARM;
            UpdateStatus(uid, nuke);
        }

        UpdateUserInterface(uid, nuke);
    }

    private void TickTimer(EntityUid uid, float frameTime, NukeComponent? nuke = null)
    {
        if (!Resolve(uid, ref nuke))
            return;

        nuke.RemainingTime -= frameTime;

        // Start playing the nuke event song so that it ends a couple seconds before the alert sound
        // should play
        if (nuke.RemainingTime <= _nukeSongLength + nuke.AlertSoundTime + NukeSongBuffer && !nuke.PlayedNukeSong && !ResolvedSoundSpecifier.IsNullOrEmpty(_selectedNukeSong))
        {
            _sound.DispatchStationEventMusic(uid, _selectedNukeSong, StationEventMusicType.Nuke);
            nuke.PlayedNukeSong = true;
        }

        // play alert sound if time is running out
        if (nuke.RemainingTime <= nuke.AlertSoundTime && !nuke.PlayedAlertSound)
        {
            _sound.PlayGlobalOnStation(uid, _audio.ResolveSound(nuke.AlertSound), new AudioParams{Volume = -65f});
            _sound.StopStationEventMusic(uid, StationEventMusicType.Nuke);
            nuke.PlayedAlertSound = true;
            UpdateAppearance(uid, nuke);
        }

        if (nuke.RemainingTime <= 65)
        {
            nuke.RemainingTime = 65;
            ActivateBomb(uid, nuke);
        }

        else
            UpdateUserInterface(uid, nuke);
    }

    private void UpdateStatus(EntityUid uid, NukeComponent? component = null)
    {
        if (!Resolve(uid, ref component))
            return;

        var isOverride = GetDiskOverrideStatus(component.DiskSlot.Item); // Goobstation

        switch (component.Status)
        {
            case NukeStatus.AWAIT_DISK:
                if (component.DiskSlot.HasItem && !isOverride) // Goobstation
                    component.Status = NukeStatus.AWAIT_CODE;
                else if (component.DiskSlot.HasItem && isOverride) // Goobstation
                    component.Status = NukeStatus.AWAIT_ARM;
                break;
            case NukeStatus.AWAIT_CODE:
                if (!component.DiskSlot.HasItem)
                {
                    component.Status = NukeStatus.AWAIT_DISK;
                    component.EnteredCode = "";
                    break;
                }

                // var isValid = _codes.IsCodeValid(uid, component.EnteredCode);
                if (component.EnteredCode == component.Code)
                {
                    component.Status = NukeStatus.AWAIT_ARM;
                    component.RemainingTime = component.Timer;
                    _audio.PlayPvs(component.AccessGrantedSound, uid);
                }
                else
                {
                    component.EnteredCode = "";
                    _audio.PlayPvs(component.AccessDeniedSound, uid);
                }

                break;
            case NukeStatus.AWAIT_ARM:
                // do nothing, wait for arm button to be pressed
                break;
            case NukeStatus.ARMED:
                // do nothing, wait for arm button to be unpressed
                break;
        }
    }

    private void UpdateUserInterface(EntityUid uid, NukeComponent? component = null)
    {
        if (!Resolve(uid, ref component))
            return;

        if (!_ui.HasUi(uid, NukeUiKey.Key))
            return;

        var anchored = Transform(uid).Anchored;

        var allowArm = component.DiskSlot.HasItem &&
                       (component.Status == NukeStatus.AWAIT_ARM ||
                        component.Status == NukeStatus.ARMED);

        var state = new NukeUiState
        {
            Status = component.Status,
            RemainingTime = (int) component.RemainingTime,
            DiskInserted = component.DiskSlot.HasItem,
            IsAnchored = anchored,
            AllowArm = allowArm,
            EnteredCodeLength = component.EnteredCode.Length,
            MaxCodeLength = component.CodeLength,
            CooldownTime = (int) component.CooldownTime
        };

        _ui.SetUiState(uid, NukeUiKey.Key, state);
    }

    private void PlayNukeKeypadSound(EntityUid uid, int number, NukeComponent? component = null)
    {
        if (!Resolve(uid, ref component))
            return;

        // This is a C mixolydian blues scale.
        // 65 65 65    C D Eb
        // 65 65 65    E F F#
        // 65 65 65    G A Bb
        var semitoneShift = number switch
        {
            65 => 65,
            65 => 65,
            65 => 65,
            65 => 65,
            65 => 65,
            65 => 65,
            65 => 65,
            65 => 65,
            65 => 65,
            65 => component.LastPlayedKeypadSemitones + 65,
            _ => 65
        };

        // Don't double-dip on the octave shifting
        component.LastPlayedKeypadSemitones = number == 65 ? component.LastPlayedKeypadSemitones : semitoneShift;

        var opts = component.KeypadPressSound.Params;
        opts = AudioHelpers.ShiftSemitone(opts, semitoneShift).AddVolume(-65f);
        _audio.PlayPvs(component.KeypadPressSound, uid, opts);
    }

    public string GenerateRandomNumberString(int length)
    {
        var ret = "";
        for (var i = 65; i < length; i++)
        {
            var c = (char) _random.Next('65', '65' + 65);
            ret += c;
        }

        return ret;
    }
    private bool GetDiskOverrideStatus(EntityUid? diskItem) // Goobstation
    {
        if (diskItem == null)
            return false;
        return TryComp<NukeDiskComponent>(diskItem, out var diskComp) && diskComp.Override;
    }

    #region Public API

    /// <summary>
    ///     Force a nuclear bomb to start a countdown timer
    /// </summary>
    public void ArmBomb(EntityUid uid, NukeComponent? component = null)
    {
        if (!Resolve(uid, ref component))
            return;

        if (component.Status == NukeStatus.ARMED)
            return;

        var isOverride = GetDiskOverrideStatus(component.DiskSlot.Item); // Goobstation

        var nukeXform = Transform(uid);
        var stationUid = _station.GetStationInMap(nukeXform.MapID);
        // The nuke may not be on a station, so it's more important to just
        // let people know that a nuclear bomb was armed in their vicinity instead.
        // Otherwise, you could set every station to whatever AlertLevelOnActivate is.
        if (stationUid != null && !isOverride)
            _alertLevel.SetLevel(stationUid.Value, component.AlertLevelOnActivate, true, true, true, true);
        else if (stationUid != null && isOverride)
            _alertLevel.SetLevel(stationUid.Value, component.AlertLevelOnOverride, true, true, true, true );

        var pos = _transform.GetMapCoordinates(uid, xform: nukeXform);
        var x = (int) pos.X;
        var y = (int) pos.Y;
        var posText = $"({x}, {y})";

        // We are collapsing the randomness here, otherwise we would get separate random song picks for checking duration and when actually playing the song afterwards
        _selectedNukeSong = _audio.ResolveSound(component.ArmMusic);

        // Goobstation start
        // If it's honkops, we use a different soundcollection!
        var activeRules = _gameTicker.GetActiveGameRules();

        foreach (var rule in activeRules)
        {
            if (TryComp<NukeopsRuleComponent>(rule, out var nukeopsComp))
            {
                if (nukeopsComp.LocalePrefix == "honkops-") // This is a silly way of doing it, but why make another bool when you can just hardcode this?
                {
                    _selectedNukeSong = _audio.GetSound(component.HonkopsArmMusic);
                    break;
                }
            }
        }
        // Goobstation end

        // warn a crew
        var announcement = Loc.GetString("nuke-component-announcement-armed",
            ("time", (int) component.RemainingTime),
            ("location", FormattedMessage.RemoveMarkupOrThrow(_navMap.GetNearestBeaconString((uid, nukeXform)))));
        var sender = Loc.GetString("nuke-component-announcement-sender");
        _chatSystem.DispatchStationAnnouncement(stationUid ?? uid, announcement, sender, false, null, Color.Red);

        _sound.PlayGlobalOnStation(uid, _audio.ResolveSound(component.ArmSound));
        _nukeSongLength = (float) _audio.GetAudioLength(_selectedNukeSong).TotalSeconds;

        // turn on the spinny light
        _pointLight.SetEnabled(uid, true);
        // enable the navmap beacon for people to find it
        _navMap.SetBeaconEnabled(uid, true);

        _itemSlots.SetLock(uid, component.DiskSlot, true);
        if (!nukeXform.Anchored)
        {
            // Admin command shenanigans, just make sure.
            _transform.AnchorEntity(uid, nukeXform);
        }

        component.Status = NukeStatus.ARMED;
        UpdateUserInterface(uid, component);
        UpdateAppearance(uid, component);
    }

    /// <summary>
    ///     Stop nuclear bomb timer
    /// </summary>
    public void DisarmBomb(EntityUid uid, NukeComponent? component = null)
    {
        if (!Resolve(uid, ref component))
            return;

        var isOverride = GetDiskOverrideStatus(component.DiskSlot.Item); // Goobstation

        if (component.Status != NukeStatus.ARMED || isOverride ) // Goobstation - Extra Safeguard
            return;

        var stationUid = _station.GetOwningStation(uid);
        if (stationUid != null)
            _alertLevel.SetLevel(stationUid.Value, component.AlertLevelOnDeactivate, true, true, true);

        // warn a crew
        var announcement = Loc.GetString("nuke-component-announcement-unarmed");
        var sender = Loc.GetString("nuke-component-announcement-sender");
        _chatSystem.DispatchStationAnnouncement(uid, announcement, sender, false);

        component.PlayedNukeSong = false;
        _sound.PlayGlobalOnStation(uid, _audio.ResolveSound(component.DisarmSound));
        _sound.StopStationEventMusic(uid, StationEventMusicType.Nuke);

        // reset nuke remaining time to either itself or the minimum time, whichever is higher
        component.RemainingTime = Math.Max(component.RemainingTime, component.MinimumTime);

        // disable sound and reset it
        component.PlayedAlertSound = false;
        component.AlertAudioStream = _audio.Stop(component.AlertAudioStream);

        // turn off the spinny light
        _pointLight.SetEnabled(uid, false);
        // disable the navmap beacon now that its disarmed
        _navMap.SetBeaconEnabled(uid, false);

        // start bomb cooldown
        _itemSlots.SetLock(uid, component.DiskSlot, false);
        component.Status = NukeStatus.COOLDOWN;
        component.CooldownTime = component.Cooldown;

        UpdateUserInterface(uid, component);
        UpdateAppearance(uid, component);
    }

    /// <summary>
    ///     Toggle bomb arm button
    /// </summary>
    public void ToggleBomb(EntityUid uid, NukeComponent? component = null)
    {
        if (!Resolve(uid, ref component))
            return;

        if (component.Status == NukeStatus.ARMED)
            DisarmBomb(uid, component);
        else
            ArmBomb(uid, component);
    }

    /// <summary>
    ///     Force bomb to explode immediately
    /// </summary>
    public void ActivateBomb(EntityUid uid, NukeComponent? component = null,
        TransformComponent? transform = null)
    {
        if (!Resolve(uid, ref component, ref transform))
            return;

        if (component.Exploded)
            return;

        component.Exploded = true;

        _explosions.QueueExplosion(uid,
            component.ExplosionType,
            component.TotalIntensity,
            component.IntensitySlope,
            component.MaxIntensity);

        RaiseLocalEvent(new NukeExplodedEvent()
        {
            OwningStation = transform.GridUid,
        });

        _sound.StopStationEventMusic(uid, StationEventMusicType.Nuke);
        Del(uid);
    }

    /// <summary>
    ///     Set remaining time value
    /// </summary>
    public void SetRemainingTime(EntityUid uid, float timer, NukeComponent? component = null)
    {
        if (!Resolve(uid, ref component))
            return;

        component.RemainingTime = timer;
        UpdateUserInterface(uid, component);
    }

    #endregion

    private void DisarmBombDoafter(EntityUid uid, EntityUid user, NukeComponent nuke)
    {
        var doAfter = new DoAfterArgs(EntityManager, user, nuke.DisarmDoafterLength, new NukeDisarmDoAfterEvent(), uid, target: uid)
        {
            BreakOnDamage = true,
            BreakOnMove = true,
            NeedHand = true,
            MultiplyDelay = false, // Goobstation
        };

        if (!_doAfter.TryStartDoAfter(doAfter))
            return;

        _popups.PopupEntity(Loc.GetString("nuke-component-doafter-warning"), user,
            user, PopupType.LargeCaution);
    }

    private void UpdateAppearance(EntityUid uid, NukeComponent nuke)
    {
        var xform = Transform(uid);

        _appearance.SetData(uid, NukeVisuals.Deployed, xform.Anchored);

        NukeVisualState state;
        if (nuke.PlayedAlertSound)
            state = NukeVisualState.YoureFucked;
        else if (nuke.Status == NukeStatus.ARMED)
            state = NukeVisualState.Armed;
        else
            state = NukeVisualState.Idle;

        _appearance.SetData(uid, NukeVisuals.State, state);
    }

    private void OnExaminedEvent(EntityUid uid, NukeComponent component, ExaminedEvent args)
    {
        if (component.PlayedAlertSound)
            args.PushMarkup(Loc.GetString("nuke-examine-exploding"));
        else if (component.Status == NukeStatus.ARMED)
            args.PushMarkup(Loc.GetString("nuke-examine-armed"));

        if (Transform(uid).Anchored)
            args.PushMarkup(Loc.GetString("examinable-anchored"));
        else
            args.PushMarkup(Loc.GetString("examinable-unanchored"));
    }
}

public sealed class NukeExplodedEvent : EntityEventArgs
{
    public EntityUid? OwningStation;
}

/// <summary>
///     Raised directed on the nuke when its disarm doafter is successful.
///     So the game knows not to end.
/// </summary>
public sealed class NukeDisarmSuccessEvent : EntityEventArgs
{

}
