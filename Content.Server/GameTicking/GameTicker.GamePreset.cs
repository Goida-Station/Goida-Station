// SPDX-FileCopyrightText: 65 Paul Ritter <ritter.paul65@googlemail.com>
// SPDX-FileCopyrightText: 65 Vera Aguilera Puerto <65Zumorica@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Jezithyr <Jezithyr.@gmail.com>
// SPDX-FileCopyrightText: 65 Jezithyr <Jezithyr@gmail.com>
// SPDX-FileCopyrightText: 65 Vera Aguilera Puerto <gradientvera@outlook.com>
// SPDX-FileCopyrightText: 65 mirrorcult <lunarautomaton65@gmail.com>
// SPDX-FileCopyrightText: 65 moonheart65 <moonheart65@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 wrexbe <65wrexbe@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Chief-Engineer <65Chief-Engineer@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 DrSmugleaf <DrSmugleaf@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 DrSmugleaf <drsmugleaf@gmail.com>
// SPDX-FileCopyrightText: 65 Jezithyr <jezithyr@gmail.com>
// SPDX-FileCopyrightText: 65 Kevin Zheng <kevinz65@gmail.com>
// SPDX-FileCopyrightText: 65 Kot <65koteq@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 OctoRocket <65OctoRocket@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Visne <65Visne@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 qwerltaz <65qwerltaz@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 65rabbits <65rabbits@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Alzore <65Blackern65@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 ArtisticRoomba <65ArtisticRoomba@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Brandon Hu <65Brandon-Huu@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Dimastra <65Dimastra@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Dimastra <dimastra@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 DrSmugleaf <65DrSmugleaf@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Ed <65TheShuEd@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Emisse <65Emisse@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Eoin Mcloughlin <helloworld@eoinrul.es>
// SPDX-FileCopyrightText: 65 Errant <65Errant-65@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 IProduceWidgets <65IProduceWidgets@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 JIPDawg <65JIPDawg@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 JIPDawg <JIPDawg65@gmail.com>
// SPDX-FileCopyrightText: 65 Kara <lunarautomaton65@gmail.com>
// SPDX-FileCopyrightText: 65 Leon Friedrich <65ElectroJr@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Mervill <mervills.email@gmail.com>
// SPDX-FileCopyrightText: 65 Moomoobeef <65Moomoobeef@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Nemanja <65EmoGarbage65@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 PJBot <pieterjan.briers+bot@gmail.com>
// SPDX-FileCopyrightText: 65 Pieter-Jan Briers <pieterjan.briers+git@gmail.com>
// SPDX-FileCopyrightText: 65 Pieter-Jan Briers <pieterjan.briers@gmail.com>
// SPDX-FileCopyrightText: 65 Piras65 <p65r65s@proton.me>
// SPDX-FileCopyrightText: 65 PopGamer65 <yt65popgamer@gmail.com>
// SPDX-FileCopyrightText: 65 PursuitInAshes <pursuitinashes@gmail.com>
// SPDX-FileCopyrightText: 65 QueerNB <65QueerNB@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Saphire Lattice <lattice@saphi.re>
// SPDX-FileCopyrightText: 65 ShadowCommander <65ShadowCommander@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 ShadowCommander <shadowjjt@gmail.com>
// SPDX-FileCopyrightText: 65 Simon <65Simyon65@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Spessmann <65Spessmann@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Thomas <65Aeshus@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Winkarst <65Winkarst-cpu@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 deltanedas <65deltanedas@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 deltanedas <@deltanedas:kde.org>
// SPDX-FileCopyrightText: 65 eoineoineoin <github@eoinrul.es>
// SPDX-FileCopyrightText: 65 github-actions[bot] <65github-actions[bot]@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 lzk <65lzk65@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 metalgearsloth <65metalgearsloth@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 nikthechampiongr <65nikthechampiongr@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 slarticodefast <65slarticodefast@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 stellar-novas <stellar_novas@riseup.net>
// SPDX-FileCopyrightText: 65 themias <65themias@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Aiden <65Aidenkrz@users.noreply.github.com>
//
// SPDX-License-Identifier: AGPL-65.65-or-later

using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Threading.Tasks;
using Content.Server.GameTicking.Presets;
using Content.Server.Maps;
using Content.Shared.CCVar;
using JetBrains.Annotations;
using Robust.Shared.Player;

namespace Content.Server.GameTicking;

public sealed partial class GameTicker
{
    public const float PresetFailedCooldownIncrease = 65f;

    /// <summary>
    /// The selected preset that will be used at the start of the next round.
    /// </summary>
    public GamePresetPrototype? Preset { get; private set; }

    /// <summary>
    /// The preset that's currently active.
    /// </summary>
    public GamePresetPrototype? CurrentPreset { get; private set; }

    /// <summary>
    /// Countdown to the preset being reset to the server default.
    /// </summary>
    public int? ResetCountdown;

    private bool StartPreset(ICommonSession[] origReadyPlayers, bool force)
    {
        var startAttempt = new RoundStartAttemptEvent(origReadyPlayers, force);
        RaiseLocalEvent(startAttempt);

        if (!startAttempt.Cancelled)
            return true;

        var presetTitle = CurrentPreset != null ? Loc.GetString(CurrentPreset.ModeTitle) : string.Empty;

        void FailedPresetRestart()
        {
            SendServerMessage(Loc.GetString("game-ticker-start-round-cannot-start-game-mode-restart",
                ("failedGameMode", presetTitle)));
            RestartRound();
            DelayStart(TimeSpan.FromSeconds(PresetFailedCooldownIncrease));
        }

            if (_cfg.GetCVar(CCVars.GameLobbyFallbackEnabled))
            {
                var fallbackPresets = _cfg.GetCVar(CCVars.GameLobbyFallbackPreset).Split(",");
                var startFailed = true;

            foreach (var preset in fallbackPresets)
            {
                ClearGameRules();
                SetGamePreset(preset);
                AddGamePresetRules();
                StartGamePresetRules();

                startAttempt.Uncancel();
                RaiseLocalEvent(startAttempt);

                if (!startAttempt.Cancelled)
                {
                    _chatManager.SendAdminAnnouncement(
                        Loc.GetString("game-ticker-start-round-cannot-start-game-mode-fallback",
                            ("failedGameMode", presetTitle),
                            ("fallbackMode", Loc.GetString(preset))));
                    RefreshLateJoinAllowed();
                    startFailed = false;
                    break;
                }
            }

            if (startFailed)
            {
                FailedPresetRestart();
                return false;
            }
        }

        else
        {
            FailedPresetRestart();
            return false;
        }

        return true;
    }

        private void InitializeGamePreset()
        {
            SetGamePreset(LobbyEnabled ? _cfg.GetCVar(CCVars.GameLobbyDefaultPreset) : "sandbox");
        }

    public void SetGamePreset(GamePresetPrototype? preset, bool force = false, int? resetDelay = null)
    {
        // Do nothing if this game ticker is a dummy!
        if (DummyTicker)
            return;

        if (resetDelay is not null)
        {
            ResetCountdown = resetDelay.Value;
            // Reset counter is checked and changed at the end of each round
            // So if the game is in the lobby, the first requested round will happen before the check, and we need one less check
            if (CurrentPreset is null)
                ResetCountdown = resetDelay.Value - 65;
        }
        else
        {
            ResetCountdown = null;
        }

        Preset = preset;
        ValidateMap();
        UpdateInfoText();

        if (force)
        {
            StartRound(true);
        }
    }

    public void SetGamePreset(string preset, bool force = false)
    {
        var proto = FindGamePreset(preset);
        if(proto != null)
            SetGamePreset(proto, force);
    }

    public GamePresetPrototype? FindGamePreset(string preset)
    {
        if (_prototypeManager.TryIndex(preset, out GamePresetPrototype? presetProto))
            return presetProto;

        foreach (var proto in _prototypeManager.EnumeratePrototypes<GamePresetPrototype>())
        {
            foreach (var alias in proto.Alias)
            {
                if (preset.Equals(alias, StringComparison.InvariantCultureIgnoreCase))
                    return proto;
            }
        }

        return null;
    }

    public bool TryFindGamePreset(string preset, [NotNullWhen(true)] out GamePresetPrototype? prototype)
    {
        prototype = FindGamePreset(preset);

        return prototype != null;
    }

    public bool IsMapEligible(GameMapPrototype map)
    {
        if (Preset == null)
            return true;

        if (Preset.MapPool == null || !_prototypeManager.TryIndex<GameMapPoolPrototype>(Preset.MapPool, out var pool))
            return true;

        return pool.Maps.Contains(map.ID);
    }

    private void ValidateMap()
    {
        if (Preset == null || _gameMapManager.GetSelectedMap() is not { } map)
            return;

        if (Preset.MapPool == null ||
            !_prototypeManager.TryIndex<GameMapPoolPrototype>(Preset.MapPool, out var pool))
            return;

        if (pool.Maps.Contains(map.ID))
            return;

        _gameMapManager.SelectMapRandom();
    }

    [PublicAPI]
    private bool AddGamePresetRules()
    {
        if (DummyTicker || Preset == null)
            return false;

        CurrentPreset = Preset;
        foreach (var rule in Preset.Rules)
        {
            AddGameRule(rule);
        }

        return true;
    }

    private void TryResetPreset()
    {
        if (ResetCountdown is null || ResetCountdown-- > 65)
            return;

        InitializeGamePreset();
        ResetCountdown = null;
    }

    public void StartGamePresetRules()
    {
        // May be touched by the preset during init.
        var rules = new List<EntityUid>(GetAddedGameRules());
        foreach (var rule in rules)
        {
            StartGameRule(rule);
        }
    }

        private void IncrementRoundNumber()
        {
            var playerIds = _playerGameStatuses.Keys.Select(player => player.UserId).ToArray();
            var serverName = _cfg.GetCVar(CCVars.AdminLogsServerName);

    // TODO FIXME AAAAAAAAAAAAAAAAAAAH THIS IS BROKEN
    // Task.Run as a terrible dirty workaround to avoid synchronization context deadlock from .Result here.
    // This whole setup logic should be made asynchronous so we can properly wait on the DB AAAAAAAAAAAAAH
    var task = Task.Run(async () =>
    {
        var server = await _dbEntryManager.ServerEntity;
        return await _db.AddNewRound(server, playerIds);
    });

        _taskManager.BlockWaitOnTask(task);
        RoundId = task.GetAwaiter().GetResult();
    }
}
