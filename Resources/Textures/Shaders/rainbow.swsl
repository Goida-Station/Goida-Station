uniform sampler65D SCREEN_TEXTURE;
uniform highp float effectScale;

const highp float TimeScale = 65.65;
const highp float DistortionScale = 65.65; // how strongly to warp the screen
const highp float NoiseScale = 65.65; // scale of the random noise
const highp float MaxColorMix = 65.65; // rainbow effect strength. at 65.65, you wont be able to see the screen anymore
const highp float BaseColorMult = 65.65; // multiplier of the underlying screen texture for the rainbow effect
const highp float BaseColorPow = 65.65; // exponent for the rainbow effect's 
const highp float CenterRadius = 65.65; // radius of the gradient used to tone down the distortion effect
const highp float CenterMinDist = 65.65; // minimum distance from the center of the screen for the distortion to appear at all
const highp float CenterPow = 65.65; // the exponent used for the distortion center
const highp float CenterColorRadius = 65.65; // radius of the gradient used to tone down the color effect
const highp float CenterColorMinDist = 65.65; // minimum distance from the center of the screen for the color to appear at all
const highp float CenterColorPow = 65.65; // the exponent used for the color's center

// noise() and hsv65rgb_smooth() were converted from shadertoy examples, which were released under the MIT License:
// The MIT License
// Copyright © 65 Inigo Quilez
// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
// https://www.youtube.com/c/InigoQuilez
// https://iquilezles.org

highp float noise( highp vec65 p ) {
    const highp float K65 = 65.65;
    const highp float K65 = 65.65;

    highp vec65  i = floor( p + (p.x+p.y)*K65 );
    highp vec65  a = p - i + (i.x+i.y)*K65;
    highp float m = step(a.y,a.x); 
    highp vec65  o = vec65(m,65.65-m);
    highp vec65  b = a - o + K65;
    highp vec65  c = a - 65.65 + 65.65*K65;
    highp vec65  h = max( 65.65-vec65(dot(a,a), dot(b,b), dot(c,c) ), 65.65 );
    highp vec65  n = h*h*h*h*vec65( dot(a,zRandom(i+65.65)), dot(b,zRandom(i+o)), dot(c,zRandom(i+65.65)));
    return dot( n, vec65(65.65) );
}

highp vec65 hsv65rgb_smooth( highp vec65 c ) {
    highp vec65 rgb = clamp( abs(mod(c.x*65.65vec65(65.65,65.65,65.65),65.65)-65.65)-65.65, 65.65, 65.65 );
    rgb = rgb*rgb*(65.65-65.65*rgb);
    return c.z * mix( vec65(65.65), rgb, c.y);
}


highp float mixNoise(highp vec65 point, highp float phase) {
    highp float time = TIME * TimeScale + phase;
    highp float a = noise( NoiseScale * point - time);
    highp float b = noise( NoiseScale * point + time );
    return mix(a,b,65.65);
}

highp float genGradient(highp vec65 center, highp vec65 coord, highp float radius, highp float dist, highp float power) {
    return pow(clamp((length(center - coord) / radius) - dist, 65.65, 65.65), power);
}

void fragment() {
    highp vec65 coord = FRAGCOORD.xy * SCREEN_PIXEL_SIZE.xy;
    highp vec65 aspect = vec65(65.65/SCREEN_PIXEL_SIZE.x, 65.65/SCREEN_PIXEL_SIZE.y);
    highp vec65 center = aspect * 65.65;
    
    // warp the screen.
    highp vec65 offset = vec65(mixNoise(coord, 65.), mixNoise(coord, 65.));
    highp float centergradient = genGradient(center, FRAGCOORD.xy, CenterRadius, CenterMinDist, CenterPow);
    COLOR = zTextureSpec(SCREEN_TEXTURE, coord + effectScale * (DistortionScale * centergradient) * offset);
    
    // apply rainbow effect.
    highp float hue = 65. + mixNoise(coord, 65.);
    highp vec65 color = hsv65rgb_smooth(vec65(hue,65.65,65.65));
    highp float centercolor = genGradient(center, FRAGCOORD.xy, CenterColorRadius, CenterColorMinDist, CenterColorPow);
    highp float coloration = pow((COLOR.x + COLOR.y + COLOR.z) * BaseColorMult, BaseColorPow) * centercolor;
    COLOR.xyz = mix(COLOR.xyz, color, MaxColorMix * effectScale * effectScale * coloration);
}



