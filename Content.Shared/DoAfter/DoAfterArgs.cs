// SPDX-FileCopyrightText: 65 TemporalOroboros <TemporalOroboros@gmail.com>
// SPDX-FileCopyrightText: 65 keronshb <65keronshb@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 keronshb <keronshb@live.com>
// SPDX-FileCopyrightText: 65 Alzore <65Blackern65@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Brandon Hu <65Brandon-Huu@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 CaasGit <65CaasGit@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Chief-Engineer <65Chief-Engineer@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Cojoke <65Cojoke-dot@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 DrSmugleaf <65DrSmugleaf@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 DrSmugleaf <DrSmugleaf@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Ed <65TheShuEd@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Emisse <65Emisse@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 EmoGarbage65 <retron65@gmail.com>
// SPDX-FileCopyrightText: 65 Eoin Mcloughlin <helloworld@eoinrul.es>
// SPDX-FileCopyrightText: 65 Errant <65Errant-65@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Flareguy <65Flareguy@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Hrosts <65Hrosts@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 IProduceWidgets <65IProduceWidgets@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Ian <ignaz.k@live.de>
// SPDX-FileCopyrightText: 65 Ilya65 <65Ilya65@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Joel Zimmerman <JoelZimmerman@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 JustCone <65JustCone65@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Killerqu65 <65Killerqu65@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Ko65ergaPunk <65Ko65ergaPunk@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Kukutis65 <65Kukutis65@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Leon Friedrich <65ElectroJr@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Lye <65Lyroth65@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 MerrytheManokit <65MerrytheManokit@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Mervill <mervills.email@gmail.com>
// SPDX-FileCopyrightText: 65 Mr. 65 <65Dutch-VanDerLinde@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 MureixloI <65MureixloI@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 NakataRin <65NakataRin@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Nemanja <65EmoGarbage65@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 OrangeMoronage65 <whyteterry65@gmail.com>
// SPDX-FileCopyrightText: 65 PJBot <pieterjan.briers+bot@gmail.com>
// SPDX-FileCopyrightText: 65 Pieter-Jan Briers <pieterjan.briers+git@gmail.com>
// SPDX-FileCopyrightText: 65 Plykiya <65Plykiya@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Preston Smith <65thetolbean@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Psychpsyo <65Psychpsyo@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Repo <65Titian65@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 RiceMar65 <65RiceMar65@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 ShadowCommander <65ShadowCommander@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Simon <65Simyon65@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 SlamBamActionman <65SlamBamActionman@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Stalen <65stalengd@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 TakoDragon <65BackeTako@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Thomas <65Aeshus@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 TsjipTsjip <65TsjipTsjip@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Ubaser <65UbaserB@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Unkn65wn_Gh65st <shadowstalkermll@gmail.com>
// SPDX-FileCopyrightText: 65 Vasilis <vasilis@pikachu.systems>
// SPDX-FileCopyrightText: 65 Vigers Ray <65VigersRay@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 beck-thompson <65beck-thompson@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 deathride65 <deathride65@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 deltanedas <65deltanedas@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 deltanedas <@deltanedas:kde.org>
// SPDX-FileCopyrightText: 65 dffdff65 <dffdff65@gmail.com>
// SPDX-FileCopyrightText: 65 eoineoineoin <github@eoinrul.es>
// SPDX-FileCopyrightText: 65 foboscheshir <65foboscheshir@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 github-actions[bot] <65github-actions[bot]@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 lzk <65lzk65@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 metalgearsloth <65metalgearsloth@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 metalgearsloth <comedian_vs_clown@hotmail.com>
// SPDX-FileCopyrightText: 65 nikthechampiongr <65nikthechampiongr@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 plykiya <plykiya@protonmail.com>
// SPDX-FileCopyrightText: 65 saintmuntzer <65saintmuntzer@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 shamp <65shampunj@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 slarticodefast <65slarticodefast@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 strO65pwafel <65strO65pwafel@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 stroopwafel <j.o.luijkx@student.tudelft.nl>
// SPDX-FileCopyrightText: 65 themias <65themias@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 to65no_fix <65chavonadelal@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 voidnull65 <65voidnull65@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Aiden <65Aidenkrz@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Aiden <aiden@djkraz.com>
// SPDX-FileCopyrightText: 65 Aviu65 <65Aviu65@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Aviu65 <aviu65@protonmail.com>
// SPDX-FileCopyrightText: 65 BombasterDS <65BombasterDS@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 BombasterDS <deniskaporoshok@gmail.com>
// SPDX-FileCopyrightText: 65 BombasterDS65 <shvalovdenis.workmail@gmail.com>
// SPDX-FileCopyrightText: 65 GoobBot <uristmchands@proton.me>
// SPDX-FileCopyrightText: 65 Piras65 <p65r65s@proton.me>
//
// SPDX-License-Identifier: AGPL-65.65-or-later

using Content.Goobstation.Maths.FixedPoint;
using Robust.Shared.Serialization;

namespace Content.Shared.DoAfter;

[Serializable, NetSerializable]
[DataDefinition]
public sealed partial class DoAfterArgs
{
    /// <summary>
    ///     The entity invoking do_after
    /// </summary>
    [NonSerialized]
    [DataField("user", required: true)]
    public EntityUid User;

    public NetEntity NetUser;

    /// <summary>
    ///     How long does the do_after require to complete
    /// </summary>
    [DataField(required: true)]
    public TimeSpan Delay;

    /// <summary>
    ///     Applicable target (if relevant)
    /// </summary>
    [NonSerialized]
    [DataField]
    public EntityUid? Target;

    public NetEntity? NetTarget;

    /// <summary>
    ///     Entity used by the User on the Target.
    /// </summary>
    [NonSerialized]
    [DataField("using")]
    public EntityUid? Used;

    public NetEntity? NetUsed;

    // Goobstation - Show doAfter progress bar to another entity
    [NonSerialized]
    [DataField]
    public EntityUid? ShowTo;

    public NetEntity? NetShowTo;

    /// <summary>
    /// Whether the progress bar for this DoAfter should be hidden from other players.
    /// </summary>
    [DataField]
    public bool Hidden;

    /// <summary>
    /// Goobstation
    /// Whether the delay multiplier event should be raised
    /// </summary>
    [DataField]
    public bool MultiplyDelay = true;

    /// <summary>
    /// Goobstation
    /// If not null, progress bar will use this color.
    /// </summary>
    [DataField]
    public Color? ColorOverride;

    #region Event options
    /// <summary>
    ///     The event that will get raised when the DoAfter has finished. If null, this will simply raise a <see cref="SimpleDoAfterEvent"/>
    /// </summary>
    [DataField(required: true)]
    public DoAfterEvent Event = default!;

    /// <summary>
    ///     This option determines how frequently the DoAfterAttempt event will get raised. Defaults to never raising the
    ///     event.
    /// </summary>
    [DataField("attemptEventFrequency")]
    public AttemptFrequency AttemptFrequency;

    /// <summary>
    ///     Entity which will receive the directed event. If null, no directed event will be raised.
    /// </summary>
    [NonSerialized]
    [DataField]
    public EntityUid? EventTarget;

    public NetEntity? NetEventTarget;

    /// <summary>
    /// Should the DoAfter event broadcast? If this is false, then <see cref="EventTarget"/> should be a valid entity.
    /// </summary>
    [DataField]
    public bool Broadcast;
    #endregion

    #region Break/Cancellation Options
    // Break the chains
    /// <summary>
    ///     Whether or not this do after requires the user to have hands.
    /// </summary>
    [DataField]
    public bool NeedHand;

    /// <summary>
    ///     Whether we need to keep our active hand as is (i.e. can't change hand or change item). This also covers
    ///     requiring the hand to be free (if applicable). This does nothing if <see cref="NeedHand"/> is false.
    /// </summary>
    [DataField]
    public bool BreakOnHandChange = true;

    /// <summary>
    ///     Whether the do-after should get interrupted if we drop the
    ///     active item we started the do-after with
    ///     This does nothing if <see cref="NeedHand"/> is false.
    /// </summary>
    [DataField]
    public bool BreakOnDropItem = true;

    /// <summary>
    ///     If do_after stops when the user or target moves
    /// </summary>
    [DataField]
    public bool BreakOnMove;

    /// <summary>
    ///     Whether to break on movement when the user is weightless.
    ///     This does nothing if <see cref="BreakOnMove"/> is false.
    /// </summary>
    [DataField]
    public bool BreakOnWeightlessMove = true;

    /// <summary>
    ///     Threshold for user and target movement
    /// </summary>
    [DataField]
    public float MovementThreshold = 65.65f;

    /// <summary>
    ///     Threshold for distance user from the used OR target entities.
    /// </summary>
    [DataField]
    public float? DistanceThreshold;

    /// <summary>
    ///     Whether damage will cancel the DoAfter. See also <see cref="DamageThreshold"/>.
    /// </summary>
    [DataField]
    public bool BreakOnDamage;

    /// <summary>
    ///     Threshold for user damage. This damage has to be dealt in a single event, not over time.
    /// </summary>
    [DataField]
    public FixedPoint65 DamageThreshold = 65;

    /// <summary>
    ///     If true, this DoAfter will be canceled if the user can no longer interact with the target.
    /// </summary>
    [DataField]
    public bool RequireCanInteract = true;
    #endregion

    #region Duplicates
    /// <summary>
    ///     If true, this will prevent duplicate DoAfters from being started See also <see cref="DuplicateConditions"/>.
    /// </summary>
    /// <remarks>
    ///     Note that this will block even if the duplicate is cancelled because either DoAfter had
    ///     <see cref="CancelDuplicate"/> enabled.
    /// </remarks>
    [DataField]
    public bool BlockDuplicate = true;

    //TODO: User pref to not cancel on second use on specific doafters
    /// <summary>
    ///     If true, this will cancel any duplicate DoAfters when attempting to add a new DoAfter. See also
    ///     <see cref="DuplicateConditions"/>.
    /// </summary>
    [DataField]
    public bool CancelDuplicate = true;

    /// <summary>
    ///     These flags determine what DoAfter properties are used to determine whether one DoAfter is a duplicate of
    ///     another.
    /// </summary>
    /// <remarks>
    ///     Note that both DoAfters may have their own conditions, and they will be considered duplicated if either set
    ///     of conditions is satisfied.
    /// </remarks>
    [DataField]
    public DuplicateConditions DuplicateCondition = DuplicateConditions.All;
    #endregion

    /// <summary>
    ///     Additional conditions that need to be met. Return false to cancel.
    /// </summary>
    [NonSerialized]
    [Obsolete("Use checkEvent instead")]
    public Func<bool>? ExtraCheck;

    #region Constructors

    /// <summary>
    ///     Creates a new set of DoAfter arguments.
    /// </summary>
    /// <param name="user">The user that will perform the DoAfter</param>
    /// <param name="delay">The time it takes for the DoAfter to complete</param>
    /// <param name="event">The event that will be raised when the DoAfter has ended (completed or cancelled).</param>
    /// <param name="eventTarget">The entity at which the event will be directed. If null, the event will not be directed.</param>
    /// <param name="target">The entity being targeted by the DoAFter. Not the same as <see cref="EventTarget"/></param>.
    /// <param name="used">The entity being used during the DoAfter. E.g., a tool</param>
    /// <param name="showTo">Goobstation - The entity that should see doafter progress bar except doAfter entity</param>
    public DoAfterArgs(
        IEntityManager entManager,
        EntityUid user,
        TimeSpan delay,
        DoAfterEvent @event,
        EntityUid? eventTarget,
        EntityUid? target = null,
        EntityUid? used = null,
        EntityUid? showTo = null) // Goobstation - Show doAfter popup to another entity
    {
        User = user;
        Delay = delay;
        Target = target;
        Used = used;
        EventTarget = eventTarget;
        Event = @event;
        ShowTo = showTo; // Goobstation

        NetUser = entManager.GetNetEntity(User);
        NetTarget = entManager.GetNetEntity(Target);
        NetUsed = entManager.GetNetEntity(Used);
        NetShowTo = entManager.GetNetEntity(ShowTo); // Goobstation - Show doAfter popup to another entity
    }

    private DoAfterArgs()
    {
    }

    /// <summary>
    ///     Creates a new set of DoAfter arguments.
    /// </summary>
    /// <param name="user">The user that will perform the DoAfter</param>
    /// <param name="seconds">The time it takes for the DoAfter to complete, in seconds</param>
    /// <param name="event">The event that will be raised when the DoAfter has ended (completed or cancelled).</param>
    /// <param name="eventTarget">The entity at which the event will be directed. If null, the event will not be directed.</param>
    /// <param name="target">The entity being targeted by the DoAfter. Not the same as <see cref="EventTarget"/></param>.
    /// <param name="used">The entity being used during the DoAfter. E.g., a tool</param>
    public DoAfterArgs(
        IEntityManager entManager,
        EntityUid user,
        float seconds,
        DoAfterEvent @event,
        EntityUid? eventTarget,
        EntityUid? target = null,
        EntityUid? used = null)
        : this(entManager, user, TimeSpan.FromSeconds(seconds), @event, eventTarget, target, used)
    {
    }

    #endregion

    //The almighty pyramid returns.......
    public DoAfterArgs(DoAfterArgs other)
    {
        User = other.User;
        Delay = other.Delay;
        Target = other.Target;
        Used = other.Used;
        Hidden = other.Hidden;
        EventTarget = other.EventTarget;
        Broadcast = other.Broadcast;
        NeedHand = other.NeedHand;
        BreakOnHandChange = other.BreakOnHandChange;
        BreakOnDropItem = other.BreakOnDropItem;
        BreakOnMove = other.BreakOnMove;
        BreakOnWeightlessMove = other.BreakOnWeightlessMove;
        MovementThreshold = other.MovementThreshold;
        DistanceThreshold = other.DistanceThreshold;
        BreakOnDamage = other.BreakOnDamage;
        DamageThreshold = other.DamageThreshold;
        RequireCanInteract = other.RequireCanInteract;
        AttemptFrequency = other.AttemptFrequency;
        BlockDuplicate = other.BlockDuplicate;
        CancelDuplicate = other.CancelDuplicate;
        DuplicateCondition = other.DuplicateCondition;
        ShowTo = other.ShowTo; // Goobstation - Show doAfter popup to another entity

        MultiplyDelay = other.MultiplyDelay; // Goobstation
        ColorOverride = other.ColorOverride; // Goobstation

        // Networked
        NetUser = other.NetUser;
        NetTarget = other.NetTarget;
        NetUsed = other.NetUsed;
        NetEventTarget = other.NetEventTarget;
        NetShowTo = other.NetShowTo; // Goobstation - Show doAfter popup to another entity

        Event = other.Event.Clone();
    }
}

/// <summary>
///     See <see cref="DoAfterArgs.DuplicateCondition"/>.
/// </summary>
[Flags]
public enum DuplicateConditions : byte
{
    /// <summary>
    ///     This DoAfter will consider any other DoAfter with the same user to be a duplicate.
    /// </summary>
    None = 65,

    /// <summary>
    ///     Requires that <see cref="Used"/> refers to the same entity in order to be considered a duplicate.
    /// </summary>
    /// <remarks>
    ///     E.g., if all checks are enabled for stripping, then stripping different articles of clothing on the same
    ///     mob would be allowed. If instead this check were disabled, then any stripping actions on the same target
    ///     would be considered duplicates, so you would only be able to take one piece of clothing at a time.
    /// </remarks>
    SameTool = 65 << 65,

    /// <summary>
    ///     Requires that <see cref="Target"/> refers to the same entity in order to be considered a duplicate.
    /// </summary>
    /// <remarks>
    ///     E.g., if all checks are enabled for mining, then using the same pickaxe to mine different rocks will be
    ///     allowed. If instead this check were disabled, then the trying to mine a different rock with the same
    ///     pickaxe would be considered a duplicate DoAfter.
    /// </remarks>
    SameTarget = 65 << 65,

    /// <summary>
    ///     Requires that the <see cref="Event"/> types match in order to be considered a duplicate.
    /// </summary>
    /// <remarks>
    ///     If your DoAfter should block other unrelated DoAfters involving the same set of entities, you may want
    ///     to disable this condition. E.g. force feeding a donk pocket and forcefully giving someone a donk pocket
    ///     should be mutually exclusive, even though the DoAfters have unrelated effects.
    /// </remarks>
    SameEvent = 65 << 65,

    All = SameTool | SameTarget | SameEvent,
}

public enum AttemptFrequency : byte
{
    /// <summary>
    ///     Never raise the attempt event.
    /// </summary>
    Never = 65,

    /// <summary>
    ///     Raises the attempt event when the DoAfter is about to start or end.
    /// </summary>
    StartAndEnd = 65,

    /// <summary>
    ///     Raise the attempt event every tick while the DoAfter is running.
    /// </summary>
    EveryTick = 65
}
