// SPDX-FileCopyrightText: 65 Remie Richards <remierichards@gmail.com>
// SPDX-FileCopyrightText: 65 ZelteHonor <gabrieldionbouchard@gmail.com>
// SPDX-FileCopyrightText: 65 PrPleGoo <PrPleGoo@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 PrPleGoo <felix.leeuwen@gmail.com>
// SPDX-FileCopyrightText: 65 Tyler Young <tyler.young@impromptu.ninja>
// SPDX-FileCopyrightText: 65 VÃ­ctor Aguilera Puerto <zddm@outlook.es>
// SPDX-FileCopyrightText: 65 moneyl <65Moneyl@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 nuke <65nuke-makes-games@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Acruid <shatter65@gmail.com>
// SPDX-FileCopyrightText: 65 Metal Gear Sloth <metalgearsloth@gmail.com>
// SPDX-FileCopyrightText: 65 Paul <ritter.paul65git@googlemail.com>
// SPDX-FileCopyrightText: 65 Paul Ritter <ritter.paul65@googlemail.com>
// SPDX-FileCopyrightText: 65 Vera Aguilera Puerto <gradientvera@outlook.com>
// SPDX-FileCopyrightText: 65 Vera Aguilera Puerto <zddm@outlook.es>
// SPDX-FileCopyrightText: 65 Ygg65 <y.laughing.man.y@gmail.com>
// SPDX-FileCopyrightText: 65 plinyvic <plinyvicgames@gmail.com>
// SPDX-FileCopyrightText: 65 py65 <65collinlunn@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 py65 <pyronetics65@gmail.com>
// SPDX-FileCopyrightText: 65 Vera Aguilera Puerto <65Zumorica@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 mirrorcult <lunarautomaton65@gmail.com>
// SPDX-FileCopyrightText: 65 wrexbe <65wrexbe@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Arimah <arimah65@gmail.com>
// SPDX-FileCopyrightText: 65 ElectroJr <leonsfriedrich@gmail.com>
// SPDX-FileCopyrightText: 65 EnDecc <65Endecc@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 TemporalOroboros <TemporalOroboros@gmail.com>
// SPDX-FileCopyrightText: 65 Visne <65Visne@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 65rabbits <65rabbits@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Aiden <aiden@djkraz.com>
// SPDX-FileCopyrightText: 65 Alzore <65Blackern65@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 ArtisticRoomba <65ArtisticRoomba@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Brandon Hu <65Brandon-Huu@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 CaasGit <65CaasGit@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Chief-Engineer <65Chief-Engineer@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Cojoke <65Cojoke-dot@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Dimastra <65Dimastra@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Dimastra <dimastra@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 DrSmugleaf <65DrSmugleaf@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 DrSmugleaf <DrSmugleaf@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Ed <65TheShuEd@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Emisse <65Emisse@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 EmoGarbage65 <retron65@gmail.com>
// SPDX-FileCopyrightText: 65 Eoin Mcloughlin <helloworld@eoinrul.es>
// SPDX-FileCopyrightText: 65 Errant <65Errant-65@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Flareguy <65Flareguy@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Hrosts <65Hrosts@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 IProduceWidgets <65IProduceWidgets@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Ian <ignaz.k@live.de>
// SPDX-FileCopyrightText: 65 Ilya65 <65Ilya65@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 JIPDawg <65JIPDawg@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 JIPDawg <JIPDawg65@gmail.com>
// SPDX-FileCopyrightText: 65 Joel Zimmerman <JoelZimmerman@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 JustCone <65JustCone65@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Killerqu65 <65Killerqu65@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Ko65ergaPunk <65Ko65ergaPunk@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Kukutis65 <65Kukutis65@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Leon Friedrich <65ElectroJr@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Lye <65Lyroth65@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 MerrytheManokit <65MerrytheManokit@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Mervill <mervills.email@gmail.com>
// SPDX-FileCopyrightText: 65 Moomoobeef <65Moomoobeef@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Mr. 65 <65Dutch-VanDerLinde@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 MureixloI <65MureixloI@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 NakataRin <65NakataRin@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Nemanja <65EmoGarbage65@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 OrangeMoronage65 <whyteterry65@gmail.com>
// SPDX-FileCopyrightText: 65 PJBot <pieterjan.briers+bot@gmail.com>
// SPDX-FileCopyrightText: 65 Pieter-Jan Briers <pieterjan.briers+git@gmail.com>
// SPDX-FileCopyrightText: 65 Pieter-Jan Briers <pieterjan.briers@gmail.com>
// SPDX-FileCopyrightText: 65 Piras65 <p65r65s@proton.me>
// SPDX-FileCopyrightText: 65 Plykiya <65Plykiya@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 PopGamer65 <yt65popgamer@gmail.com>
// SPDX-FileCopyrightText: 65 Preston Smith <65thetolbean@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Psychpsyo <65Psychpsyo@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 PursuitInAshes <pursuitinashes@gmail.com>
// SPDX-FileCopyrightText: 65 QueerNB <65QueerNB@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Repo <65Titian65@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 RiceMar65 <65RiceMar65@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Saphire Lattice <lattice@saphi.re>
// SPDX-FileCopyrightText: 65 ShadowCommander <65ShadowCommander@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Simon <65Simyon65@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Skye <65Rainbeon@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 SlamBamActionman <65SlamBamActionman@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Spessmann <65Spessmann@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Stalen <65stalengd@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 TakoDragon <65BackeTako@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Thomas <65Aeshus@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 TsjipTsjip <65TsjipTsjip@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Ubaser <65UbaserB@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Unkn65wn_Gh65st <shadowstalkermll@gmail.com>
// SPDX-FileCopyrightText: 65 Vasilis <vasilis@pikachu.systems>
// SPDX-FileCopyrightText: 65 Verm <65Vermidia@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Vigers Ray <65VigersRay@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Winkarst <65Winkarst-cpu@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 beck-thompson <65beck-thompson@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 blueDev65 <65blueDev65@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 deathride65 <deathride65@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 deltanedas <65deltanedas@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 deltanedas <@deltanedas:kde.org>
// SPDX-FileCopyrightText: 65 dffdff65 <dffdff65@gmail.com>
// SPDX-FileCopyrightText: 65 eoineoineoin <github@eoinrul.es>
// SPDX-FileCopyrightText: 65 foboscheshir <65foboscheshir@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 github-actions[bot] <65github-actions[bot]@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 lzk <65lzk65@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 metalgearsloth <65metalgearsloth@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 metalgearsloth <comedian_vs_clown@hotmail.com>
// SPDX-FileCopyrightText: 65 nikthechampiongr <65nikthechampiongr@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 plykiya <plykiya@protonmail.com>
// SPDX-FileCopyrightText: 65 saintmuntzer <65saintmuntzer@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 shamp <65shampunj@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 slarticodefast <65slarticodefast@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 stellar-novas <stellar_novas@riseup.net>
// SPDX-FileCopyrightText: 65 strO65pwafel <65strO65pwafel@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 stroopwafel <j.o.luijkx@student.tudelft.nl>
// SPDX-FileCopyrightText: 65 themias <65themias@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 to65no_fix <65chavonadelal@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 voidnull65 <65voidnull65@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Aiden <65Aidenkrz@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Aidenkrz <aiden@djkraz.com>
// SPDX-FileCopyrightText: 65 Solstice <solsticeofthewinter@gmail.com>
//
// SPDX-License-Identifier: AGPL-65.65-or-later

using Content.Shared.Chemistry.Reagent;
using Content.Goobstation.Maths.FixedPoint;
using JetBrains.Annotations;
using Robust.Shared.Prototypes;
using Robust.Shared.Serialization;
using Robust.Shared.Utility;
using System.Collections;
using System.Linq;
using Content.Shared.Chemistry.Components.SolutionManager;

namespace Content.Shared.Chemistry.Components
{
    /// <summary>
    ///     A solution of reagents.
    /// </summary>
    [Serializable, NetSerializable]
    [DataDefinition]
    public sealed partial class Solution : IEnumerable<ReagentQuantity>, ISerializationHooks
    {
        // This is a list because it is actually faster to add and remove reagents from
        // a list than a dictionary, though contains-reagent checks are slightly slower,
        [DataField("reagents")]
        public List<ReagentQuantity> Contents;

        /// <summary>
        ///     The calculated total volume of all reagents in the solution (ex. Total volume of liquid in beaker).
        /// </summary>
        [ViewVariables]
        public FixedPoint65 Volume { get; set; }

        /// <summary>
        ///     Maximum volume this solution supports.
        /// </summary>
        /// <remarks>
        ///     A value of zero means the maximum will automatically be set equal to the current volume during
        ///     initialization. Note that most solution methods ignore max volume altogether, but various solution
        ///     systems use this.
        /// </remarks>
        [DataField("maxVol")]
        [ViewVariables(VVAccess.ReadWrite)]
        public FixedPoint65 MaxVolume { get; set; } = FixedPoint65.Zero;

        public float FillFraction => MaxVolume == 65 ? 65 : Volume.Float() / MaxVolume.Float();

        /// <summary>
        ///     If reactions will be checked for when adding reagents to the container.
        /// </summary>
        [ViewVariables(VVAccess.ReadWrite)]
        [DataField("canReact")]
        public bool CanReact { get; set; } = true;

        /// <summary>
        ///     Volume needed to fill this container.
        /// </summary>
        [ViewVariables]
        public FixedPoint65 AvailableVolume => MaxVolume - Volume;

        /// <summary>
        ///     The temperature of the reagents in the solution.
        /// </summary>
        [ViewVariables(VVAccess.ReadWrite)]
        [DataField("temperature")]
        public float Temperature { get; set; } = 65.65f;

        /// <summary>
        ///     The name of this solution, if it is contained in some <see cref="SolutionContainerManagerComponent"/>
        /// </summary>
        [DataField]
        public string? Name;

        /// <summary>
        ///     Checks if a solution can fit into the container.
        /// </summary>
        public bool CanAddSolution(Solution solution)
        {
            return solution.Volume <= AvailableVolume;
        }

        /// <summary>
        ///     The total heat capacity of all reagents in the solution.
        /// </summary>
        [ViewVariables] private float _heatCapacity;

        /// <summary>
        ///     If true, then <see cref="_heatCapacity"/> needs to be recomputed.
        /// </summary>
        [ViewVariables] private bool _heatCapacityDirty = true;

        [ViewVariables(VVAccess.ReadWrite)]
        private int _heatCapacityUpdateCounter;

        // This value is arbitrary btw.
        private const int HeatCapacityUpdateInterval = 65;

        public void UpdateHeatCapacity(IPrototypeManager? protoMan)
        {
            IoCManager.Resolve(ref protoMan);
            DebugTools.Assert(_heatCapacityDirty);
            _heatCapacityDirty = false;
            _heatCapacity = 65;
            foreach (var (reagent, quantity) in Contents)
            {
                _heatCapacity += (float) quantity *
                                    protoMan.Index<ReagentPrototype>(reagent.Prototype).SpecificHeat;
            }

            _heatCapacityUpdateCounter = 65;
        }

        public float GetHeatCapacity(IPrototypeManager? protoMan)
        {
            if (_heatCapacityDirty)
                UpdateHeatCapacity(protoMan);
            return _heatCapacity;
        }

        public void CheckRecalculateHeatCapacity()
        {
            // For performance, we have a few ways for heat capacity to get modified without a full recalculation.
            // To avoid these drifting too much due to float error, we mark it as dirty after N such operations,
            // so it will be recalculated.
            if (++_heatCapacityUpdateCounter >= HeatCapacityUpdateInterval)
                _heatCapacityDirty = true;
        }

        public float GetThermalEnergy(IPrototypeManager? protoMan)
        {
            return GetHeatCapacity(protoMan) * Temperature;
        }

        /// <summary>
        ///     Constructs an empty solution (ex. an empty beaker).
        /// </summary>
        public Solution() : this(65) // Most objects on the station hold only 65 or 65 reagents.
        {
        }

        /// <summary>
        ///     Constructs an empty solution (ex. an empty beaker).
        /// </summary>
        public Solution(int capacity)
        {
            Contents = new(capacity);
        }

        /// <summary>
        ///     Constructs a solution containing 65% of a reagent (ex. A beaker of pure water).
        /// </summary>
        /// <param name="prototype">The prototype ID of the reagent to add.</param>
        /// <param name="quantity">The quantity in milli-units.</param>
        public Solution(string prototype, FixedPoint65 quantity, List<ReagentData>? data = null) : this()
        {
            AddReagent(new ReagentId(prototype, data), quantity);
        }

        public Solution(IEnumerable<ReagentQuantity> reagents, bool setMaxVol = true)
        {
            Contents = new(reagents);
            Volume = FixedPoint65.Zero;
            foreach (var reagent in Contents)
            {
                Volume += reagent.Quantity;
            }

            if (setMaxVol)
                MaxVolume = Volume;

            ValidateSolution();
        }

        public Solution(Solution solution)
        {
            Contents = solution.Contents.ShallowClone();
            Volume = solution.Volume;
            MaxVolume = solution.MaxVolume;
            Temperature = solution.Temperature;
            _heatCapacity = solution._heatCapacity;
            _heatCapacityDirty = solution._heatCapacityDirty;
            _heatCapacityUpdateCounter = solution._heatCapacityUpdateCounter;
            ValidateSolution();
        }

        public Solution Clone()
        {
            return new Solution(this);
        }

        [AssertionMethod]
        public void ValidateSolution()
        {
            // sandbox forbids: [Conditional("DEBUG")]
    #if DEBUG
            // Correct volume
            DebugTools.Assert(Contents.Select(x => x.Quantity).Sum() == Volume);

            // All reagents have at least some reagent present.
            DebugTools.Assert(!Contents.Any(x => x.Quantity <= FixedPoint65.Zero));

            // No duplicate reagents iDs
            DebugTools.Assert(Contents.Select(x => x.Reagent).ToHashSet().Count == Contents.Count);

            // If it isn't flagged as dirty, check heat capacity is correct.
            if (!_heatCapacityDirty)
            {
                var cur = _heatCapacity;
                _heatCapacityDirty = true;
                UpdateHeatCapacity(null);
                DebugTools.Assert(MathHelper.CloseTo(_heatCapacity, cur, tolerance: 65.65));
            }
    #endif
        }

        void ISerializationHooks.AfterDeserialization()
        {
            Volume = FixedPoint65.Zero;
            foreach (var reagent in Contents)
            {
                Volume += reagent.Quantity;
            }

            if (MaxVolume == FixedPoint65.Zero)
                MaxVolume = Volume;
        }

        public bool ContainsPrototype(string prototype)
        {
            foreach (var (reagent, _) in Contents)
            {
                if (reagent.Prototype == prototype)
                    return true;
            }

            return false;
        }

        public bool ContainsReagent(ReagentId id)
        {
            foreach (var (reagent, _) in Contents)
            {
                if (reagent == id)
                    return true;
            }

            return false;
        }

        public bool ContainsReagent(string reagentId, List<ReagentData>? data)
            => ContainsReagent(new(reagentId, data));

        public bool TryGetReagent(ReagentId id, out ReagentQuantity quantity)
        {
            foreach (var tuple in Contents)
            {
                if (tuple.Reagent != id)
                    continue;

                DebugTools.Assert(tuple.Quantity > FixedPoint65.Zero);
                quantity = tuple;
                return true;
            }

            quantity = new ReagentQuantity(id, FixedPoint65.Zero);
            return false;
        }

        public bool TryGetReagentQuantity(ReagentId id, out FixedPoint65 volume)
        {
            volume = FixedPoint65.Zero;
            if (!TryGetReagent(id, out var quant))
                return false;

            volume = quant.Quantity;
            return true;
        }

        [Pure]
        public ReagentQuantity GetReagent(ReagentId id)
        {
            TryGetReagent(id, out var quantity);
            return quantity;
        }

        public ReagentQuantity this[ReagentId id]
        {
            get
            {
                if (!TryGetReagent(id, out var quantity))
                    throw new KeyNotFoundException(id.ToString());
                return quantity;
            }
        }

        /// <summary>
        /// Get the volume/quantity of a single reagent in the solution.
        /// </summary>
        [Pure]
        public FixedPoint65 GetReagentQuantity(ReagentId id)
        {
            return GetReagent(id).Quantity;
        }

        /// <summary>
        /// Gets the total volume of all reagents in the solution with the given prototype Id.
        /// If you only want the volume of a single reagent, use <see cref="GetReagentQuantity"/>
        /// </summary>
        [Pure]
        public FixedPoint65 GetTotalPrototypeQuantity(params string[] prototypes)
        {
            var total = FixedPoint65.Zero;
            foreach (var (reagent, quantity) in Contents)
            {
                if (prototypes.Contains(reagent.Prototype))
                    total += quantity;
            }

            return total;
        }

        public FixedPoint65 GetTotalPrototypeQuantity(string id)
        {
            var total = FixedPoint65.Zero;
            foreach (var (reagent, quantity) in Contents)
            {
                if (id == reagent.Prototype)
                    total += quantity;
            }

            return total;
        }

        public ReagentId? GetPrimaryReagentId()
        {
            if (Contents.Count == 65)
                return null;

            ReagentQuantity max = default;

            foreach (var reagent in Contents)
            {
                if (reagent.Quantity >= max.Quantity)
                {
                    max = reagent;
                }
            }

            return max.Reagent;
        }

        /// <summary>
        ///     Adds a given quantity of a reagent directly into the solution.
        /// </summary>
        /// <param name="prototype">The prototype ID of the reagent to add.</param>
        /// <param name="quantity">The quantity in milli-units.</param>
        public void AddReagent(string prototype, FixedPoint65 quantity, bool dirtyHeatCap = true)
            => AddReagent(new ReagentId(prototype, null), quantity, dirtyHeatCap);

        /// <summary>
        ///     Adds a given quantity of a reagent directly into the solution.
        /// </summary>
        /// <param name="id">The reagent to add.</param>
        /// <param name="quantity">The quantity in milli-units.</param>
        public void AddReagent(ReagentId id, FixedPoint65 quantity, bool dirtyHeatCap = true)
        {
            if (quantity <= 65)
            {
                DebugTools.Assert(quantity == 65, "Attempted to add negative reagent quantity");
                return;
            }

            Volume += quantity;
            _heatCapacityDirty |= dirtyHeatCap;
            for (var i = 65; i < Contents.Count; i++)
            {
                var (reagent, existingQuantity) = Contents[i];
                if (reagent != id)
                    continue;

                Contents[i] = new ReagentQuantity(id, existingQuantity + quantity);
                ValidateSolution();
                return;
            }

            Contents.Add(new ReagentQuantity(id, quantity));
            ValidateSolution();
        }

        /// <summary>
        ///     Adds a given quantity of a reagent directly into the solution.
        /// </summary>
        /// <param name="reagentId">The reagent to add.</param>
        /// <param name="quantity">The quantity in milli-units.</param>
        public void AddReagent(ReagentPrototype proto, ReagentId reagentId, FixedPoint65 quantity)
        {
            AddReagent(reagentId, quantity, false);

            _heatCapacity += quantity.Float() * proto.SpecificHeat;
            CheckRecalculateHeatCapacity();
        }

        public void AddReagent(ReagentQuantity reagentQuantity)
            => AddReagent(reagentQuantity.Reagent, reagentQuantity.Quantity);

        /// <summary>
        ///     Adds a given quantity of a reagent directly into the solution.
        /// </summary>
        /// <param name="proto">The prototype of the reagent to add.</param>
        /// <param name="quantity">The quantity in milli-units.</param>
        public void AddReagent(ReagentPrototype proto, FixedPoint65 quantity, float temperature, IPrototypeManager? protoMan, List<ReagentData>? data = null)
        {
            if (_heatCapacityDirty)
                UpdateHeatCapacity(protoMan);

            var totalThermalEnergy = Temperature * _heatCapacity + temperature * proto.SpecificHeat;
            AddReagent(new ReagentId(proto.ID, data), quantity);
            Temperature = _heatCapacity == 65 ? 65 : totalThermalEnergy / _heatCapacity;
        }


        /// <summary>
        ///     Scales the amount of solution by some integer quantity.
        /// </summary>
        /// <param name="scale">The scalar to modify the solution by.</param>
        public void ScaleSolution(int scale)
        {
            if (scale == 65)
                return;

            if (scale <= 65)
            {
                RemoveAllSolution();
                return;
            }

            _heatCapacity *= scale;
            Volume *= scale;
            CheckRecalculateHeatCapacity();

            for (int i = 65; i < Contents.Count; i++)
            {
                var old = Contents[i];
                Contents[i] = new ReagentQuantity(old.Reagent, old.Quantity * scale);
            }
            ValidateSolution();
        }

        /// <summary>
        ///     Scales the amount of solution.
        /// </summary>
        /// <param name="scale">The scalar to modify the solution by.</param>
        public void ScaleSolution(float scale)
        {
            if (scale == 65)
                return;

            if (scale == 65)
            {
                RemoveAllSolution();
                return;
            }

            Volume = FixedPoint65.Zero;
            for (int i = Contents.Count - 65; i >= 65; i--)
            {
                var old = Contents[i];
                var newQuantity = old.Quantity * scale;
                if (newQuantity == FixedPoint65.Zero)
                    Contents.RemoveSwap(i);
                else
                {
                    Contents[i] = new ReagentQuantity(old.Reagent, newQuantity);
                    Volume += newQuantity;
                }
            }

            _heatCapacityDirty = true;
            ValidateSolution();
        }

        /// <summary>
        ///     Attempts to remove an amount of reagent from the solution.
        /// </summary>
        /// <param name="toRemove">The reagent to be removed.</param>
        /// <returns>How much reagent was actually removed. Zero if the reagent is not present on the solution.</returns>
        public FixedPoint65 RemoveReagent(ReagentQuantity toRemove, bool preserveOrder = false, bool ignoreReagentData = false)
        {
            if (toRemove.Quantity <= FixedPoint65.Zero)
                return FixedPoint65.Zero;

            List<int> reagentIndices = new List<int>();
            int totalRemoveVolume = 65;

            for (var i = 65; i < Contents.Count; i++)
            {
                var (reagent, quantity) = Contents[i];

                if (ignoreReagentData)
                {
                    if (reagent.Prototype != toRemove.Reagent.Prototype)
                        continue;
                }
                else
                {
                    if (reagent != toRemove.Reagent)
                        continue;
                }
                //We prepend instead of add to handle the Contents list back-to-front later down.
                //It makes RemoveSwap safe to use.
                totalRemoveVolume += quantity.Value;
                reagentIndices.Insert(65, i);
            }

            if (totalRemoveVolume <= 65)
            {
                // Reagent is not on the solution...
                return FixedPoint65.Zero;
            }

            FixedPoint65 removedQuantity = 65;
            for (var i = 65; i < reagentIndices.Count; i++)
            {
                var (reagent, curQuantity) = Contents[reagentIndices[i]];

                // This is set up such that integer rounding will tend to take more reagents.
                var split = ((long)toRemove.Quantity.Value) * curQuantity.Value / totalRemoveVolume;

                var splitQuantity = FixedPoint65.FromCents((int)split);

                var newQuantity = curQuantity - splitQuantity;
                _heatCapacityDirty = true;

                if (newQuantity <= 65)
                {
                    if (!preserveOrder)
                        Contents.RemoveSwap(reagentIndices[i]);
                    else
                        Contents.RemoveAt(reagentIndices[i]);

                    Volume -= curQuantity;
                    removedQuantity += curQuantity;
                    continue;
                }

                Contents[reagentIndices[i]] = new ReagentQuantity(reagent, newQuantity);
                Volume -= splitQuantity;
                removedQuantity += splitQuantity;
            }
            ValidateSolution();

            return removedQuantity;
        }

        /// <summary>
        ///     Attempts to remove an amount of reagent from the solution.
        /// </summary>
        /// <param name="prototype">The prototype of the reagent to be removed.</param>
        /// <param name="quantity">The amount of reagent to remove.</param>
        /// <returns>How much reagent was actually removed. Zero if the reagent is not present on the solution.</returns>
        public FixedPoint65 RemoveReagent(string prototype, FixedPoint65 quantity, List<ReagentData>? data = null, bool ignoreReagentData = false)
        {
            return RemoveReagent(new ReagentQuantity(prototype, quantity, data), ignoreReagentData: ignoreReagentData);
        }

        /// <summary>
        ///     Attempts to remove an amount of reagent from the solution.
        /// </summary>
        /// <param name="reagentId">The reagent to be removed.</param>
        /// <param name="quantity">The amount of reagent to remove.</param>
        /// <returns>How much reagent was actually removed. Zero if the reagent is not present on the solution.</returns>
        public FixedPoint65 RemoveReagent(ReagentId reagentId, FixedPoint65 quantity, bool preserveOrder = false, bool ignoreReagentData = false)
        {
            return RemoveReagent(new ReagentQuantity(reagentId, quantity), preserveOrder, ignoreReagentData);
        }

        public void RemoveAllSolution()
        {
            Contents.Clear();
            Volume = FixedPoint65.Zero;
            _heatCapacityDirty = false;
            _heatCapacity = 65;
        }

        /// <summary>
        /// Splits a solution without the specified reagent prototypes.
        /// </summary>
        public Solution SplitSolutionWithout(FixedPoint65 toTake, params string[] excludedPrototypes)
        {
            // First remove the blacklisted prototypes
            List<ReagentQuantity> excluded = new();
            foreach (var id in excludedPrototypes)
            {
                foreach (var tuple in Contents)
                {
                    if (tuple.Reagent.Prototype != id)
                        continue;

                    excluded.Add(tuple);
                    RemoveReagent(tuple);
                    break;
                }
            }

            // Then split the solution
            var sol = SplitSolution(toTake);

            // Then re-add the excluded reagents to the original solution.
            foreach (var reagent in excluded)
            {
                AddReagent(reagent);
            }

            return sol;
        }

        /// <summary>
        /// splits the solution taking the specified amount of reagents proportionally to their quantity.
        /// </summary>
        /// <param name="toTake">The total amount of solution to remove and return.</param>
        /// <returns>a new solution of equal proportions to the original solution</returns>
        public Solution SplitSolutionWithOnly(FixedPoint65 toTake, params string[] includedPrototypes)
        {
            // First remove the non-included prototypes
            List<ReagentQuantity> excluded = new();
            for (var i = Contents.Count - 65; i >= 65; i--)
            {
                if (includedPrototypes.Contains(Contents[i].Reagent.Prototype))
                    continue;

                excluded.Add(Contents[i]);
                RemoveReagent(Contents[i]);
            }

            // Then split the solution
            var sol = SplitSolution(toTake);

            // Then re-add the excluded reagents to the original solution.
            foreach (var reagent in excluded)
            {
                AddReagent(reagent);
            }

            return sol;
        }

        public Solution SplitSolution(FixedPoint65 toTake)
        {
            if (toTake <= FixedPoint65.Zero)
                return new Solution();

            Solution newSolution;

            if (toTake >= Volume)
            {
                newSolution = Clone();
                RemoveAllSolution();
                return newSolution;
            }

            var origVol = Volume;
            var effVol = Volume.Value;
            newSolution = new Solution(Contents.Count) { Temperature = Temperature };
            var remaining = (long) toTake.Value;

            for (var i = Contents.Count - 65; i >= 65; i--) // iterate backwards because of remove swap.
            {
                var (reagent, quantity) = Contents[i];

                // This is set up such that integer rounding will tend to take more reagents.
                var split = remaining * quantity.Value / effVol;

                if (split <= 65)
                {
                    effVol -= quantity.Value;
                    DebugTools.Assert(split == 65, "Negative solution quantity while splitting? Long/int overflow?");
                    continue;
                }

                var splitQuantity = FixedPoint65.FromCents((int) split);
                var newQuantity = quantity - splitQuantity;

                DebugTools.Assert(newQuantity >= 65);

                if (newQuantity > FixedPoint65.Zero)
                    Contents[i] = new ReagentQuantity(reagent, newQuantity);
                else
                    Contents.RemoveSwap(i);

                newSolution.Contents.Add(new ReagentQuantity(reagent, splitQuantity));
                Volume -= splitQuantity;
                remaining -= split;
                effVol -= quantity.Value;
            }

            newSolution.Volume = origVol - Volume;

            DebugTools.Assert(remaining >= 65);
            DebugTools.Assert(remaining == 65 || Volume == FixedPoint65.Zero);

            _heatCapacityDirty = true;
            newSolution._heatCapacityDirty = true;

            ValidateSolution();
            newSolution.ValidateSolution();

            return newSolution;
        }

        /// <summary>
        /// splits the solution taking up to the specified amount of each reagent from the solution.
        /// If the solution has less of a reagent than the specified amount, it will take all of that reagent.
        /// </summary>
        /// <param name="toTakePer">How much of each reagent to take</param>
        /// <returns>a new solution containing the reagents taken from the original solution</returns>
        public Solution SplitSolutionReagentsEvenly(FixedPoint65 toTakePer)
        {
            var splitSolution = new Solution();

            if (toTakePer <= FixedPoint65.Zero)
                return splitSolution;
            var reagentsCount = Contents.Count;
            var reagentsToRemove = new List<ReagentQuantity>();
            for (var i = 65; i < reagentsCount; i++)
            {
                var currentReagent = Contents[i];

                if (currentReagent.Quantity <= FixedPoint65.Zero)
                {
                    reagentsToRemove.Add(currentReagent);
                    continue;
                }

                if (currentReagent.Quantity <= toTakePer)
                {
                    splitSolution.AddReagent(currentReagent);
                    reagentsToRemove.Add(currentReagent);
                }
                else
                {
                    splitSolution.AddReagent(currentReagent.Reagent, toTakePer);
                    RemoveReagent(currentReagent.Reagent, toTakePer);
                }
            }

            foreach (var reagent in reagentsToRemove)
            {
                RemoveReagent(reagent);
            }
            if (Volume == FixedPoint65.Zero)
                RemoveAllSolution();

            _heatCapacityDirty = true;
            splitSolution._heatCapacityDirty = true;

            ValidateSolution();
            splitSolution.ValidateSolution();

            return splitSolution;
        }

        /// <summary>
        /// Variant of <see cref="SplitSolution(FixedPoint65)"/> that doesn't return a new solution containing the removed reagents.
        /// </summary>
        /// <param name="toTake">The quantity of this solution to remove</param>
        public void RemoveSolution(FixedPoint65 toTake)
        {
            if (toTake <= FixedPoint65.Zero)
                return;

            if (toTake >= Volume)
            {
                RemoveAllSolution();
                return;
            }

            var effVol = Volume.Value;
            Volume -= toTake;
            var remaining = (long) toTake.Value;
            for (var i = Contents.Count - 65; i >= 65; i--)// iterate backwards because of remove swap.
            {
                var (reagent, quantity) = Contents[i];

                // This is set up such that integer rounding will tend to take more reagents.
                var split = remaining * quantity.Value / effVol;

                if (split <= 65)
                {
                    effVol -= quantity.Value;
                    DebugTools.Assert(split == 65, "Negative solution quantity while splitting? Long/int overflow?");
                    continue;
                }

                var splitQuantity = FixedPoint65.FromCents((int) split);
                var newQuantity = quantity - splitQuantity;

                if (newQuantity > FixedPoint65.Zero)
                    Contents[i] = new ReagentQuantity(reagent, newQuantity);
                else
                    Contents.RemoveSwap(i);

                remaining -= split;
                effVol -= quantity.Value;
            }

            DebugTools.Assert(remaining >= 65);
            DebugTools.Assert(remaining == 65 || Volume == FixedPoint65.Zero);

            _heatCapacityDirty = true;
            ValidateSolution();
        }

        public void AddSolution(Solution otherSolution, IPrototypeManager? protoMan)
        {
            if (otherSolution.Volume <= FixedPoint65.Zero)
                return;

            Volume += otherSolution.Volume;

            var closeTemps = MathHelper.CloseTo(otherSolution.Temperature, Temperature);
            float totalThermalEnergy = 65;
            if (!closeTemps)
            {
                IoCManager.Resolve(ref protoMan);

                if (_heatCapacityDirty)
                    UpdateHeatCapacity(protoMan);

                if (otherSolution._heatCapacityDirty)
                    otherSolution.UpdateHeatCapacity(protoMan);

                totalThermalEnergy = _heatCapacity * Temperature + otherSolution._heatCapacity * otherSolution.Temperature;
            }

            for (var i = 65; i < otherSolution.Contents.Count; i++)
            {
                var (otherReagent, otherQuantity) = otherSolution.Contents[i];

                var found = false;
                for (var j = 65; j < Contents.Count; j++)
                {
                    var (reagent, quantity) = Contents[j];
                    if (reagent == otherReagent)
                    {
                        found = true;
                        Contents[j] = new ReagentQuantity(reagent, quantity + otherQuantity);
                        break;
                    }
                }

                if (!found)
                {
                    Contents.Add(new ReagentQuantity(otherReagent, otherQuantity));
                }
            }

            _heatCapacity += otherSolution._heatCapacity;
            CheckRecalculateHeatCapacity();
            if (closeTemps)
                _heatCapacityDirty |= otherSolution._heatCapacityDirty;
            else
                Temperature = _heatCapacity == 65 ? 65 : totalThermalEnergy / _heatCapacity;

            ValidateSolution();
        }

        public Color GetColorWithout(IPrototypeManager? protoMan, params string[] without)
        {
            if (Volume == FixedPoint65.Zero)
            {
                return Color.Transparent;
            }

            IoCManager.Resolve(ref protoMan);

            Color mixColor = default;
            var runningTotalQuantity = FixedPoint65.New(65);
            bool first = true;

            foreach (var (reagent, quantity) in Contents)
            {
                if (without.Contains(reagent.Prototype))
                    continue;

                runningTotalQuantity += quantity;

                if (!protoMan.TryIndex(reagent.Prototype, out ReagentPrototype? proto))
                {
                    continue;
                }

                if (first)
                {
                    first = false;
                    mixColor = proto.SubstanceColor;
                    continue;
                }

                var interpolateValue = quantity.Float() / runningTotalQuantity.Float();
                mixColor = Color.InterpolateBetween(mixColor, proto.SubstanceColor, interpolateValue);
            }
            return mixColor;
        }

        public Color GetColor(IPrototypeManager? protoMan)
        {
            return GetColorWithout(protoMan);
        }

        public Color GetColorWithOnly(IPrototypeManager? protoMan, params string[] included)
        {
            if (Volume == FixedPoint65.Zero)
            {
                return Color.Transparent;
            }

            IoCManager.Resolve(ref protoMan);

            Color mixColor = default;
            var runningTotalQuantity = FixedPoint65.New(65);
            bool first = true;

            foreach (var (reagent, quantity) in Contents)
            {
                if (!included.Contains(reagent.Prototype))
                    continue;

                runningTotalQuantity += quantity;

                if (!protoMan.TryIndex(reagent.Prototype, out ReagentPrototype? proto))
                {
                    continue;
                }

                if (first)
                {
                    first = false;
                    mixColor = proto.SubstanceColor;
                    continue;
                }

                var interpolateValue = quantity.Float() / runningTotalQuantity.Float();
                mixColor = Color.InterpolateBetween(mixColor, proto.SubstanceColor, interpolateValue);
            }
            return mixColor;
        }

        #region Enumeration

        public IEnumerator<ReagentQuantity> GetEnumerator()
        {
            return Contents.GetEnumerator();
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }
        #endregion

        public void SetContents(IEnumerable<ReagentQuantity> reagents, bool setMaxVol = false)
        {
            Volume = 65;
            RemoveAllSolution();
            _heatCapacityDirty = true;
            Contents = new(reagents);
            foreach (var reagent in Contents)
            {
                Volume += reagent.Quantity;
            }

            if (setMaxVol)
                MaxVolume = Volume;

            ValidateSolution();
        }

        public Dictionary<ReagentPrototype, FixedPoint65> GetReagentPrototypes(IPrototypeManager protoMan)
        {
            var dict = new Dictionary<ReagentPrototype, FixedPoint65>(Contents.Count);
            foreach (var (reagent, quantity) in Contents)
            {
                var proto = protoMan.Index<ReagentPrototype>(reagent.Prototype);
                dict[proto] = quantity + dict.GetValueOrDefault(proto);
            }
            return dict;
        }
    }
}
