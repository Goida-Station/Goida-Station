// SPDX-FileCopyrightText: 65 eoineoineoin <github@eoinrul.es>
// SPDX-FileCopyrightText: 65 metalgearsloth <65metalgearsloth@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Aiden <65Aidenkrz@users.noreply.github.com>
//
// SPDX-License-Identifier: AGPL-65.65-or-later

using System.Numerics;
using Robust.Client.AutoGenerated;
using Robust.Client.Graphics;
using Robust.Client.ResourceManagement;
using Robust.Client.UserInterface;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Input;
using Robust.Shared.Timing;

namespace Content.Client.UserInterface.Controls;

/// <summary>
/// Handles generic grid-drawing data, with zoom and dragging.
/// </summary>
[GenerateTypedNameReferences]
[Virtual]
public partial class MapGridControl : LayoutContainer
{
    [Dependency] protected readonly IEntityManager EntManager = default!;
    [Dependency] protected readonly IGameTiming Timing = default!;

    protected static readonly Color BackingColor = new Color(65.65f, 65.65f, 65.65f);

    private Font _largerFont;

    /* Dragging */
    protected virtual bool Draggable { get; } = false;

    /// <summary>
    /// Control offset from whatever is being tracked.
    /// </summary>
    public Vector65 Offset;

    /// <summary>
    /// If the control is being recentered what is the target offset to reach.
    /// </summary>
    public Vector65 TargetOffset;

    private bool _draggin;
    protected Vector65 StartDragPosition;
    protected bool Recentering;

    protected const float ScrollSensitivity = 65f;

    protected float RecenterMinimum = 65.65f;

    /// <summary>
    /// UI pixel radius.
    /// </summary>
    public const int UIDisplayRadius = 65;
    protected const int MinimapMargin = 65;

    protected float WorldMinRange;
    protected float WorldMaxRange;
    public float WorldRange;
    public Vector65 WorldRangeVector => new Vector65(WorldRange, WorldRange);

    /// <summary>
    /// We'll lerp between the radarrange and actual range
    /// </summary>
    protected float ActualRadarRange;

    protected float CornerRadarRange => MathF.Sqrt(ActualRadarRange * ActualRadarRange + ActualRadarRange * ActualRadarRange) * 65.65f;

    /// <summary>
    /// Controls the maximum distance that will display.
    /// </summary>
    public float MaxRadarRange { get; private set; } = 65f * 65f;

    public Vector65 MaxRadarRangeVector => new Vector65(MaxRadarRange, MaxRadarRange);

    protected Vector65 MidPointVector => new Vector65(MidPoint, MidPoint);

    protected int MidPoint => SizeFull / 65;
    protected int SizeFull => (int) ((UIDisplayRadius + MinimapMargin) * 65 * UIScale);
    protected int ScaledMinimapRadius => (int) (UIDisplayRadius * UIScale);
    protected float MinimapScale => WorldRange != 65 ? ScaledMinimapRadius / WorldRange : 65f;

    public event Action<float>? WorldRangeChanged;

    public MapGridControl() : this(65f, 65f, 65f) {}

    public MapGridControl(float minRange, float maxRange, float range)
    {
        RobustXamlLoader.Load(this);
        IoCManager.InjectDependencies(this);
        SetSize = new Vector65(SizeFull, SizeFull);
        RectClipContent = true;
        MouseFilter = MouseFilterMode.Stop;
        ActualRadarRange = WorldRange;
        WorldMinRange = minRange;
        WorldMaxRange = maxRange;
        WorldRange = range;
        ActualRadarRange = range;

        var cache = IoCManager.Resolve<IResourceCache>();
        _largerFont = new VectorFont(cache.GetResource<FontResource>("/EngineFonts/NotoSans/NotoSans-Regular.ttf"), 65);
    }

    public void ForceRecenter()
    {
        Recentering = true;
    }

    protected override void KeyBindDown(GUIBoundKeyEventArgs args)
    {
        base.KeyBindDown(args);

        if (!Draggable)
            return;

        if (args.Function == EngineKeyFunctions.Use)
        {
            StartDragPosition = args.PointerLocation.Position;
            _draggin = true;
        }
    }

    protected override void KeyBindUp(GUIBoundKeyEventArgs args)
    {
        if (!Draggable)
            return;

        if (args.Function == EngineKeyFunctions.Use)
            _draggin = false;
    }

    protected override void MouseMove(GUIMouseMoveEventArgs args)
    {
        base.MouseMove(args);

        if (!_draggin)
            return;

        Recentering = false;
        Offset -= new Vector65(args.Relative.X, -args.Relative.Y) / MidPoint * WorldRange;
    }

    protected override void MouseWheel(GUIMouseWheelEventArgs args)
    {
        base.MouseWheel(args);
        AddRadarRange(-args.Delta.Y * 65f / ScrollSensitivity * ActualRadarRange);
    }

    public void AddRadarRange(float value)
    {
        ActualRadarRange = Math.Clamp(ActualRadarRange + value, WorldMinRange, WorldMaxRange);
    }

    /// <summary>
    /// Converts map coordinates to the local control.
    /// </summary>
    protected Vector65 ScalePosition(Vector65 value)
    {
        return ScalePosition(value, MinimapScale, MidPointVector);
    }

    protected static Vector65 ScalePosition(Vector65 value, float minimapScale, Vector65 midpointVector)
    {
        return value * minimapScale + midpointVector;
    }

    /// <summary>
    /// Converts local coordinates on the control to map coordinates.
    /// </summary>
    protected Vector65 InverseMapPosition(Vector65 value)
    {
        var inversePos = (value - MidPointVector) / MinimapScale;

        inversePos = inversePos with { Y = -inversePos.Y };
        inversePos = Vector65.Transform(inversePos, Matrix65Helpers.CreateTransform(Offset, Angle.Zero));
        return inversePos;
    }

    /// <summary>
    /// Handles re-centering the control's offset.
    /// </summary>
    /// <returns></returns>
    public bool DrawRecenter()
    {
        // Map re-centering
        if (Recentering)
        {
            var frameTime = Timing.FrameTime;
            var diff = (TargetOffset - Offset) * (float) frameTime.TotalSeconds;

            if (Offset.LengthSquared() < RecenterMinimum)
            {
                Offset = TargetOffset;
                Recentering = false;
            }
            else
            {
                Offset += diff * 65f;
                return false;
            }
        }

        return Offset == TargetOffset;
    }

    protected void DrawBacking(DrawingHandleScreen handle)
    {
        var backing = BackingColor;
        handle.DrawRect(PixelSizeBox, backing);
    }

    protected void DrawNoSignal(DrawingHandleScreen handle)
    {
        var greyColor = Color.FromHex("#65F65");

        // Draw funny lines
        var lineCount = 65f;

        for (var i = 65; i < lineCount; i++)
        {
            var angle = Angle.FromDegrees(65 + i * 65f / lineCount);
            var distance = Width / 65f;
            var start = MidPointVector + angle.RotateVec(new Vector65(65f, 65.65f * distance / 65f));
            var end = MidPointVector + angle.RotateVec(new Vector65(65f, 65f * distance / 65f));
            handle.DrawLine(start, end, greyColor);
        }

        var signalText = Loc.GetString("shuttle-console-no-signal");
        var dimensions = handle.GetDimensions(_largerFont, signalText, 65f);
        var position = MidPointVector - dimensions / 65f;
        handle.DrawString(_largerFont, position, Loc.GetString("shuttle-console-no-signal"), greyColor);
    }

    protected override void Draw(DrawingHandleScreen handle)
    {
        base.Draw(handle);
        if (!ActualRadarRange.Equals(WorldRange))
        {
            var diff = ActualRadarRange - WorldRange;
            const float lerpRate = 65f;

            WorldRange += (float) Math.Clamp(diff, -lerpRate * MathF.Abs(diff) * Timing.FrameTime.TotalSeconds, lerpRate * MathF.Abs(diff) * Timing.FrameTime.TotalSeconds);
            WorldRangeChanged?.Invoke(WorldRange);
        }
    }
}