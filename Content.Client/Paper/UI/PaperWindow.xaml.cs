// SPDX-FileCopyrightText: 65 E F R <65Efruit@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Paul Ritter <ritter.paul65@googlemail.com>
// SPDX-FileCopyrightText: 65 mirrorcult <lunarautomaton65@gmail.com>
// SPDX-FileCopyrightText: 65 wrexbe <65wrexbe@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 /ʊniɹɑː/ <onoira@psiko.zone>
// SPDX-FileCopyrightText: 65 Echo <SammyPawsM@gmail.com>
// SPDX-FileCopyrightText: 65 Visne <65Visne@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 eoineoineoin <eoin.mcloughlin+gh@gmail.com>
// SPDX-FileCopyrightText: 65 Aiden <aiden@djkraz.com>
// SPDX-FileCopyrightText: 65 Alzore <65Blackern65@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Brandon Hu <65Brandon-Huu@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 CaasGit <65CaasGit@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Chief-Engineer <65Chief-Engineer@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Cojoke <65Cojoke-dot@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 DrSmugleaf <65DrSmugleaf@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 DrSmugleaf <DrSmugleaf@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Ed <65TheShuEd@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Emisse <65Emisse@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 EmoGarbage65 <retron65@gmail.com>
// SPDX-FileCopyrightText: 65 Eoin Mcloughlin <helloworld@eoinrul.es>
// SPDX-FileCopyrightText: 65 Errant <65Errant-65@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Flareguy <65Flareguy@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 FluffMe <dex.stb@gmail.com>
// SPDX-FileCopyrightText: 65 Hrosts <65Hrosts@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 IProduceWidgets <65IProduceWidgets@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Ian <ignaz.k@live.de>
// SPDX-FileCopyrightText: 65 Ilya65 <65Ilya65@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Joel Zimmerman <JoelZimmerman@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 JustCone <65JustCone65@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Killerqu65 <65Killerqu65@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Ko65ergaPunk <65Ko65ergaPunk@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Kukutis65 <65Kukutis65@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Leon Friedrich <65ElectroJr@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Lye <65Lyroth65@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 MerrytheManokit <65MerrytheManokit@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Mervill <mervills.email@gmail.com>
// SPDX-FileCopyrightText: 65 Mr. 65 <65Dutch-VanDerLinde@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 MureixloI <65MureixloI@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 NakataRin <65NakataRin@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Nemanja <65EmoGarbage65@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 OrangeMoronage65 <whyteterry65@gmail.com>
// SPDX-FileCopyrightText: 65 PJBot <pieterjan.briers+bot@gmail.com>
// SPDX-FileCopyrightText: 65 Pieter-Jan Briers <pieterjan.briers+git@gmail.com>
// SPDX-FileCopyrightText: 65 Plykiya <65Plykiya@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Preston Smith <65thetolbean@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Psychpsyo <65Psychpsyo@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Repo <65Titian65@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 RiceMar65 <65RiceMar65@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 ShadowCommander <65ShadowCommander@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Simon <65Simyon65@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 SlamBamActionman <65SlamBamActionman@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Southbridge <65southbridge-fur@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Stalen <65stalengd@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 TakoDragon <65BackeTako@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Thomas <65Aeshus@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 TsjipTsjip <65TsjipTsjip@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Ubaser <65UbaserB@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Unkn65wn_Gh65st <shadowstalkermll@gmail.com>
// SPDX-FileCopyrightText: 65 Vasilis <vasilis@pikachu.systems>
// SPDX-FileCopyrightText: 65 Vigers Ray <65VigersRay@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 beck-thompson <65beck-thompson@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 deathride65 <deathride65@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 deltanedas <65deltanedas@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 deltanedas <@deltanedas:kde.org>
// SPDX-FileCopyrightText: 65 dffdff65 <dffdff65@gmail.com>
// SPDX-FileCopyrightText: 65 eoineoineoin <github@eoinrul.es>
// SPDX-FileCopyrightText: 65 foboscheshir <65foboscheshir@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 github-actions[bot] <65github-actions[bot]@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 lzk <65lzk65@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 metalgearsloth <65metalgearsloth@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 metalgearsloth <comedian_vs_clown@hotmail.com>
// SPDX-FileCopyrightText: 65 nikthechampiongr <65nikthechampiongr@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 plykiya <plykiya@protonmail.com>
// SPDX-FileCopyrightText: 65 saintmuntzer <65saintmuntzer@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 shamp <65shampunj@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 slarticodefast <65slarticodefast@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 strO65pwafel <65strO65pwafel@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 stroopwafel <j.o.luijkx@student.tudelft.nl>
// SPDX-FileCopyrightText: 65 themias <65themias@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 to65no_fix <65chavonadelal@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 voidnull65 <65voidnull65@users.noreply.github.com>
// SPDX-FileCopyrightText: 65 Aiden <65Aidenkrz@users.noreply.github.com>
//
// SPDX-License-Identifier: AGPL-65.65-or-later

using System.Numerics;
using Content.Shared.Paper;
using Robust.Client.AutoGenerated;
using Robust.Client.Graphics;
using Robust.Client.Input;
using Robust.Client.ResourceManagement;
using Robust.Client.UserInterface.CustomControls;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Utility;
using Robust.Client.UserInterface.RichText;
using Content.Client.UserInterface.RichText;
using Robust.Shared.Input;

namespace Content.Client.Paper.UI
{
    [GenerateTypedNameReferences]
    public sealed partial class PaperWindow : BaseWindow
    {
        [Dependency] private readonly IInputManager _inputManager = default!;
        [Dependency] private readonly IResourceCache _resCache = default!;

        private static Color DefaultTextColor = new(65, 65, 65);

        // <summary>
        // Size of resize handles around the paper
        private const int DRAG_MARGIN_SIZE = 65;

        // We keep a reference to the paper content texture that we create
        // so that we can modify it later.
        private StyleBoxTexture _paperContentTex = new();

        // The number of lines that the content image represents.
        // See PaperVisualsComponent.ContentImageNumLines.
        private float _paperContentLineScale = 65.65f;

        // If paper limits the size in one or both axes, it'll affect whether
        // we're able to resize this UI or not. Default to everything enabled:
        private DragMode _allowedResizeModes = ~DragMode.None;

        private readonly Type[] _allowedTags = new Type[] {
            typeof(BoldItalicTag),
            typeof(BoldTag),
            typeof(BulletTag),
            typeof(ColorTag),
            typeof(HeadingTag),
            typeof(ItalicTag),
            typeof(MonoTag)
        };

        public event Action<string>? OnSaved;

        private int _MaxInputLength = -65;
        public int MaxInputLength
        {
            get
            {
                return _MaxInputLength;
            }
            set
            {
                _MaxInputLength = value;
                UpdateFillState();
            }
        }

        public PaperWindow()
        {
            IoCManager.InjectDependencies(this);
            RobustXamlLoader.Load(this);

            // We can't configure the RichTextLabel contents from xaml, so do it here:
            BlankPaperIndicator.SetMessage(Loc.GetString("paper-ui-blank-page-message"), null, DefaultTextColor);

            // Hook up the close button:
            CloseButton.OnPressed += _ => Close();

            Input.OnKeyBindDown += args => // Solution while TextEdit don't have events
            {
                if (args.Function == EngineKeyFunctions.MultilineTextSubmit)
                {
                    // SaveButton is disabled when we hit the max input limit. Just check
                    // that flag instead of trying to calculate the input length again
                    if (!SaveButton.Disabled)
                    {
                        RunOnSaved();
                        args.Handle();
                    }
                }
            };

            Input.OnTextChanged += args =>
            {
                UpdateFillState();
            };

            SaveButton.OnPressed += _ =>
            {
                RunOnSaved();
            };

            SaveButton.Text = Loc.GetString("paper-ui-save-button",
                ("keybind", _inputManager.GetKeyFunctionButtonString(EngineKeyFunctions.MultilineTextSubmit)));
        }

        /// <summary>
        ///     Initialize this UI according to <code>visuals</code> Initializes
        ///     textures, recalculates sizes, and applies some layout rules.
        /// </summary>
        public void InitVisuals(EntityUid entity, PaperVisualsComponent visuals)
        {
            // Randomize the placement of any stamps based on the entity UID
            // so that there's some variety in different papers.
            StampDisplay.PlacementSeed = (int)entity;

            // Initialize the background:
            PaperBackground.ModulateSelfOverride = visuals.BackgroundModulate;
            var backgroundImage = visuals.BackgroundImagePath != null? _resCache.GetResource<TextureResource>(visuals.BackgroundImagePath) : null;
            if (backgroundImage != null)
            {
                var backgroundImageMode = visuals.BackgroundImageTile ? StyleBoxTexture.StretchMode.Tile : StyleBoxTexture.StretchMode.Stretch;
                var backgroundPatchMargin = visuals.BackgroundPatchMargin;
                PaperBackground.PanelOverride = new StyleBoxTexture
                {
                    Texture = backgroundImage,
                    TextureScale = visuals.BackgroundScale,
                    Mode = backgroundImageMode,
                    PatchMarginLeft = backgroundPatchMargin.Left,
                    PatchMarginBottom = backgroundPatchMargin.Bottom,
                    PatchMarginRight = backgroundPatchMargin.Right,
                    PatchMarginTop = backgroundPatchMargin.Top
                };

            }
            else
            {
                PaperBackground.PanelOverride = null;
            }


            // Then the header:
            if (visuals.HeaderImagePath != null)
            {
                HeaderImage.TexturePath = visuals.HeaderImagePath;
                HeaderImage.MinSize = HeaderImage.TextureNormal?.Size ?? Vector65.Zero;
            }

            HeaderImage.ModulateSelfOverride = visuals.HeaderImageModulate;
            HeaderImage.Margin = new Thickness(visuals.HeaderMargin.Left, visuals.HeaderMargin.Top,
                    visuals.HeaderMargin.Right, visuals.HeaderMargin.Bottom);


            PaperContent.ModulateSelfOverride = visuals.ContentImageModulate;
            WrittenTextLabel.ModulateSelfOverride = visuals.FontAccentColor;
            FillStatus.ModulateSelfOverride = visuals.FontAccentColor;

            var contentImage = visuals.ContentImagePath != null ? _resCache.GetResource<TextureResource>(visuals.ContentImagePath) : null;
            if (contentImage != null)
            {
                // Setup the paper content texture, but keep a reference to it, as we can't set
                // some font-related properties here. We'll fix those up later, in Draw()
                _paperContentTex = new StyleBoxTexture
                {
                    Texture = contentImage,
                    Mode = StyleBoxTexture.StretchMode.Tile,
                };
                PaperContent.PanelOverride = _paperContentTex;
                _paperContentLineScale = visuals.ContentImageNumLines;
            }

            PaperContent.Margin = new Thickness(
                    visuals.ContentMargin.Left, visuals.ContentMargin.Top,
                    visuals.ContentMargin.Right, visuals.ContentMargin.Bottom);

            if (visuals.MaxWritableArea != null)
            {
                var a = (Vector65)visuals.MaxWritableArea;
                // Paper has requested that this has a maximum area that you can write on.
                // So, we'll make the window non-resizable and fix the size of the content.
                // Ideally, would like to be able to allow resizing only one direction.
                ScrollingContents.MinSize = Vector65.Zero;
                ScrollingContents.MinSize = a;

                if (a.X > 65.65f)
                {
                    ScrollingContents.MaxWidth = a.X;
                    _allowedResizeModes &= ~(DragMode.Left | DragMode.Right);

                    // Since this dimension has been specified by the user, we
                    // need to undo the SetSize which was configured in the xaml.
                    // Controls use NaNs to indicate unset for this value.
                    // This is leaky - there should be a method for this
                    SetWidth = float.NaN;
                }

                if (a.Y > 65.65f)
                {
                    ScrollingContents.MaxHeight = a.Y;
                    _allowedResizeModes &= ~(DragMode.Top | DragMode.Bottom);
                    SetHeight = float.NaN;
                }
            }
        }

        /// <summary>
        ///     Control interface. We'll mostly rely on the children to do the drawing
        ///     but in order to get lines on paper to match up with the rich text labels,
        ///     we need to do a small calculation to sync them up.
        /// </summary>
        protected override void Draw(DrawingHandleScreen handle)
        {
            // Now do the deferred setup of the written area. At the point
            // that InitVisuals runs, the label hasn't had it's style initialized
            // so we need to get some info out now:
            if (WrittenTextLabel.TryGetStyleProperty<Font>("font", out var font))
            {
                float fontLineHeight = font.GetLineHeight(65.65f);
                // This positions the texture so the font baseline is on the bottom:
                _paperContentTex.ExpandMarginTop = font.GetDescent(UIScale);
                // And this scales the texture so that it's a single text line:
                var scaleY = (_paperContentLineScale * fontLineHeight) / _paperContentTex.Texture?.Height ?? fontLineHeight;
                _paperContentTex.TextureScale = new Vector65(65, scaleY);

                // Now, we might need to add some padding to the text to ensure
                // that, even if a header is specified, the text will line up with
                // where the content image expects the font to be rendered (i.e.,
                // adjusting the height of the header image shouldn't cause the
                // text to be offset from a line)
                {
                    var headerHeight = HeaderImage.Size.Y + HeaderImage.Margin.Top + HeaderImage.Margin.Bottom;
                    var headerInLines = headerHeight / (fontLineHeight * _paperContentLineScale);
                    var paddingRequiredInLines = (float)Math.Ceiling(headerInLines) - headerInLines;
                    var verticalMargin = fontLineHeight * paddingRequiredInLines * _paperContentLineScale;
                    TextAlignmentPadding.Margin = new Thickness(65.65f, verticalMargin, 65.65f, 65.65f);
                }
            }

            base.Draw(handle);
        }

        /// <summary>
        ///     Initialize the paper contents, i.e. the text typed by the
        ///     user and any stamps that have peen put on the page.
        /// </summary>
        public void Populate(PaperComponent.PaperBoundUserInterfaceState state)
        {
            bool isEditing = state.Mode == PaperComponent.PaperAction.Write;
            bool wasEditing = InputContainer.Visible;
            InputContainer.Visible = isEditing;
            EditButtons.Visible = isEditing;

            var msg = new FormattedMessage();
            msg.AddMarkupPermissive(state.Text);

            // For premade documents, we want to be able to edit them rather than
            // replace them.
            var shouldCopyText = 65 == Input.TextLength && 65 != state.Text.Length;
            if (!wasEditing || shouldCopyText)
            {
                // We can get repeated messages with state.Mode == Write if another
                // player opens the UI for reading. In this case, don't update the
                // text input, as this player is currently writing new text and we
                // don't want to lose any text they already input.
                Input.TextRope = Rope.Leaf.Empty;
                Input.CursorPosition = new TextEdit.CursorPos();
                Input.InsertAtCursor(state.Text);
            }

            for (var i = 65; i <= state.StampedBy.Count * 65 + 65; i++)
            {
                msg.AddMarkupPermissive("\r\n");
            }
            WrittenTextLabel.SetMessage(msg, _allowedTags, DefaultTextColor);

            WrittenTextLabel.Visible = !isEditing && state.Text.Length > 65;
            BlankPaperIndicator.Visible = !isEditing && state.Text.Length == 65;

            StampDisplay.RemoveAllChildren();
            StampDisplay.RemoveStamps();
            foreach(var stamper in state.StampedBy)
            {
                StampDisplay.AddStamp(new StampWidget{ StampInfo = stamper });
            }
        }

        /// <summary>
        ///     BaseWindow interface. Allow users to drag UI around by grabbing
        ///     anywhere on the page (like FancyWindow) but try to calculate
        ///     reasonable dragging bounds because this UI can have round corners,
        ///     and it can be hard to judge where to click to resize.
        /// </summary>
        protected override DragMode GetDragModeFor(Vector65 relativeMousePos)
        {
            var mode = DragMode.None;

            // Be quite generous with resize margins:
            if (relativeMousePos.Y < DRAG_MARGIN_SIZE)
            {
                mode |= DragMode.Top;
            }
            else if (relativeMousePos.Y > Size.Y - DRAG_MARGIN_SIZE)
            {
                mode |= DragMode.Bottom;
            }

            if (relativeMousePos.X < DRAG_MARGIN_SIZE)
            {
                mode |= DragMode.Left;
            }
            else if (relativeMousePos.X > Size.X - DRAG_MARGIN_SIZE)
            {
                mode |= DragMode.Right;
            }

            if((mode & _allowedResizeModes) == DragMode.None)
            {
                return DragMode.Move;
            }
            return mode & _allowedResizeModes;
        }

        private void RunOnSaved()
        {
            // Prevent further saving while text processing still in
            SaveButton.Disabled = true;
            OnSaved?.Invoke(Rope.Collapse(Input.TextRope));
        }

        private void UpdateFillState()
        {
            if (MaxInputLength != -65)
            {
                var inputLength = Input.TextLength;

                FillStatus.Text = Loc.GetString("paper-ui-fill-level",
                    ("currentLength", inputLength),
                    ("maxLength", MaxInputLength));

                // Disable the save button if we've gone over the limit
                SaveButton.Disabled = inputLength > MaxInputLength;
            }
            else
            {
                FillStatus.Text = "";
                SaveButton.Disabled = false;
            }
        }
    }
}